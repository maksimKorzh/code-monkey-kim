ca65 V2.18 - Git 2acb3b15
Main file   : a1basic.s
Current file: a1basic.s

000000r 1               ; Apple 1 BASIC
000000r 1               ;
000000r 1               ; Modifications to build with CC65 by Jeff Tranter <tranter@pobox.com>
000000r 1               ;
000000r 1               ; Apple 1 BASIC was written by Steve Wozniak
000000r 1               ; Uses disassembly copyright 2003 Eric Smith <eric@brouhaha.com>
000000r 1               ; http://www.brouhaha.com/~eric/retrocomputing/apple/apple1/basic/
000000r 1               
000000r 1               Z1d     =       $1D
000000r 1               ch      =       $24     ; horizontal cursor location
000000r 1               var     =       $48
000000r 1               lomem   =       $4A     ; lower limit of memory used by BASIC (2 bytes)
000000r 1               himem   =       $4C     ; upper limit of memory used by BASIC (2 bytes)
000000r 1               rnd     =       $4E     ; random number (2 bytes)
000000r 1               
000000r 1               ; The noun stack and syntax stack appear to overlap, which is OK since
000000r 1               ; they apparently are not used simultaneously.
000000r 1               
000000r 1               ; The noun stack size appears to be 32 entries, based on LDX #$20
000000r 1               ; instruction at e67f.  However, there seems to be enough room for
000000r 1               ; another 8 entries.  The noun stack builds down from noun_stk_<part>+$1f
000000r 1               ; to noun_stk_<part>+$00, indexed by the X register.
000000r 1               
000000r 1               ; Noun stack usage appears to be:
000000r 1               ;   integer:
000000r 1               ;       (noun_stk_h_int,noun_stk_l) = value
000000r 1               ;       noun_stk_h_str = 0
000000r 1               ;   string:
000000r 1               ;       (noun_stk_h_str,noun_stk_l) = pointer to string
000000r 1               ;       noun_stk_h_int = any
000000r 1               ; Since noun_stk_h_str determines whether stack entry is integer or string,
000000r 1               ; strings can't start in zero page.
000000r 1               
000000r 1               noun_stk_l =    $50
000000r 1               syn_stk_h =     $58     ; through $77
000000r 1               noun_stk_h_str = $78
000000r 1               syn_stk_l  =    $80     ; through $9F
000000r 1               noun_stk_h_int = $A0
000000r 1               txtndxstk  =    $A8     ; through $C7
000000r 1               text_index =    $C8     ; index into text being tokenized (in buffer at $0200)
000000r 1               leadbl  =       $C9     ; leading blanks
000000r 1               pp      =       $CA     ; pointer to end of program (2 bytes)
000000r 1               pv      =       $CC     ; pointer to end of variable storage (2 bytes)
000000r 1               acc     =       $CE     ; (2 bytes)
000000r 1               srch    =       $D0
000000r 1               tokndxstk =     $D1
000000r 1               srch2   =       $D2
000000r 1               if_flag =       $D4
000000r 1               cr_flag =       $D5
000000r 1               current_verb =  $D6
000000r 1               precedence =    $D7
000000r 1               x_save  =       $D8
000000r 1               run_flag =      $D9
000000r 1               aux     =       $DA
000000r 1               pline   =       $DC     ; pointer to current program line (2 bytes)
000000r 1               pverb   =       $E0     ; pointer to current verb (2 bytes)
000000r 1               p1      =       $E2
000000r 1               p2      =       $E4
000000r 1               p3      =       $E6
000000r 1               token_index =   $F1    ; pointer used to write tokens into buffer  2 bytes)
000000r 1               pcon    =       $F2    ; temp used in decimal output (2 bytes)
000000r 1               auto_inc =      $F4
000000r 1               auto_ln =       $F6
000000r 1               auto_flag =     $F8
000000r 1               char    =       $F9
000000r 1               leadzr  =       $FA
000000r 1               for_nest_count = $FB    ; count of active (nested) FOR loops
000000r 1               gosub_nest_count = $FC  ; count of active (nested) subroutines calls (GOSUB)
000000r 1               synstkdx =      $FD
000000r 1               synpag  =       $FE
000000r 1               
000000r 1               ; GOSUB stack, max eight entries
000000r 1               ; note that the Apple II version has sixteen entries
000000r 1               gstk_pverbl     =       $0100    ; saved pverb
000000r 1               gstk_pverbh     =       $0108
000000r 1               gstk_plinel     =       $0110    ; saved pline
000000r 1               gstk_plineh     =       $0118
000000r 1               
000000r 1               ; FOR stack, max eight entries
000000r 1               ; note that the Apple II version has sixteen entries
000000r 1               fstk_varl       =       $0120   ; pointer to index variable
000000r 1               fstk_varh       =       $0128
000000r 1               fstk_stepl      =       $0130   ; step value
000000r 1               fstk_steph      =       $0138
000000r 1               fstk_plinel     =       $0140   ; saved pline
000000r 1               fstk_plineh     =       $0148
000000r 1               fstk_pverbl     =       $0150   ; saved pverb
000000r 1               fstk_pverbh     =       $0158
000000r 1               fstk_tol        =       $0160   ; "to" (limit) value
000000r 1               fstk_toh        =       $0168
000000r 1               buffer  =       $0200
000000r 1               KBD     =       $D010
000000r 1               KBDCR   =       $D011
000000r 1               DSP     =       $D012
000000r 1               
000000r 1                       .org    $E000
00E000  1                       .export START
00E000  1  4C B0 E2     START:  JMP     cold            ; BASIC cold start entry point
00E003  1               
00E003  1               ; Get character for keyboard, return in A.
00E003  1  AD 11 D0     rdkey:  LDA     KBDCR           ; Read control register
00E006  1  10 FB                BPL     rdkey           ; Loop if no key pressed
00E008  1  AD 10 D0             LDA     KBD             ; Read key data
00E00B  1  60                   RTS                     ; and return
00E00C  1               
00E00C  1  8A           Se00c:  TXA
00E00D  1  29 20                AND     #$20
00E00F  1  F0 23                BEQ     Le034
00E011  1               
00E011  1  A9 A0        Se011:  LDA     #$A0
00E013  1  85 E4                STA     p2
00E015  1  4C C9 E3             JMP     cout
00E018  1               
00E018  1  A9 20        Se018:  LDA     #$20
00E01A  1               
00E01A  1  C5 24        Se01a:  CMP     ch
00E01C  1  B0 0C                BCS     nextbyte
00E01E  1  A9 8D                LDA     #$8D
00E020  1  A0 07                LDY     #$07
00E022  1  20 C9 E3     Le022:  JSR     cout
00E025  1  A9 A0                LDA     #$A0
00E027  1  88                   DEY
00E028  1  D0 F8                BNE     Le022
00E02A  1               
00E02A  1  A0 00        nextbyte:       LDY     #$00
00E02C  1  B1 E2                LDA     (p1),Y
00E02E  1  E6 E2                INC     p1
00E030  1  D0 02                BNE     Le034
00E032  1  E6 E3                INC     p1+1
00E034  1  60           Le034:  RTS
00E035  1               
00E035  1               ; token $75 - "," in LIST command
00E035  1  20 15 E7     list_comman:    JSR     get16bit
00E038  1  20 76 E5             JSR     find_line2
00E03B  1  A5 E2        Le03b:  LDA     p1
00E03D  1  C5 E6                CMP     p3
00E03F  1  A5 E3                LDA     p1+1
00E041  1  E5 E7                SBC     p3+1
00E043  1  B0 EF                BCS     Le034
00E045  1  20 6D E0             JSR     list_line
00E048  1  4C 3B E0             JMP     Le03b
00E04B  1               
00E04B  1               ; token $76 - LIST command w/ no args
00E04B  1  A5 CA        list_all:       LDA     pp
00E04D  1  85 E2                STA     p1
00E04F  1  A5 CB                LDA     pp+1
00E051  1  85 E3                STA     p1+1
00E053  1  A5 4C                LDA     himem
00E055  1  85 E6                STA     p3
00E057  1  A5 4D                LDA     himem+1
00E059  1  85 E7                STA     p3+1
00E05B  1  D0 DE                BNE     Le03b
00E05D  1               
00E05D  1               ; token $74 - LIST command w/ line number(s)
00E05D  1  20 15 E7     list_cmd:       JSR     get16bit
00E060  1  20 6D E5             JSR     find_line
00E063  1  A5 E4                LDA     p2
00E065  1  85 E2                STA     p1
00E067  1  A5 E5                LDA     p2+1
00E069  1  85 E3                STA     p1+1
00E06B  1  B0 C7                BCS     Le034
00E06D  1               
00E06D  1               ; list one program line
00E06D  1  86 D8        list_line:      STX     x_save
00E06F  1  A9 A0                LDA     #$A0
00E071  1  85 FA                STA     leadzr
00E073  1  20 2A E0             JSR     nextbyte
00E076  1  98                   TYA
00E077  1               
00E077  1               ; list an integer (line number or literal)
00E077  1  85 E4        list_int:       STA     p2
00E079  1  20 2A E0             JSR     nextbyte
00E07C  1  AA                   TAX
00E07D  1  20 2A E0             JSR     nextbyte
00E080  1  20 1B E5             JSR     prdec
00E083  1  20 18 E0     Le083:  JSR     Se018
00E086  1  84 FA                STY     leadzr
00E088  1  AA                   TAX
00E089  1  10 18                BPL     list_token
00E08B  1  0A                   ASL
00E08C  1  10 E9                BPL     list_int
00E08E  1  A5 E4                LDA     p2
00E090  1  D0 03                BNE     Le095
00E092  1  20 11 E0             JSR     Se011
00E095  1  8A           Le095:  TXA
00E096  1  20 C9 E3     Le096:  JSR     cout
00E099  1  A9 25        Le099:  LDA     #$25
00E09B  1  20 1A E0             JSR     Se01a
00E09E  1  AA                   TAX
00E09F  1  30 F5                BMI     Le096
00E0A1  1  85 E4                STA     p2
00E0A3  1               
00E0A3  1               ; list a single token
00E0A3  1  C9 01        list_token:     CMP     #$01
00E0A5  1  D0 05                BNE     Le0ac
00E0A7  1  A6 D8                LDX     x_save
00E0A9  1  4C CD E3             JMP     crout
00E0AC  1  48           Le0ac:  PHA
00E0AD  1  84 CE                STY     acc
00E0AF  1  A2 ED                LDX     #$ED
00E0B1  1  86 CF                STX     acc+1
00E0B3  1  C9 51                CMP     #$51
00E0B5  1  90 04                BCC     Le0bb
00E0B7  1  C6 CF                DEC     acc+1
00E0B9  1  E9 50                SBC     #$50
00E0BB  1  48           Le0bb:  PHA
00E0BC  1  B1 CE                LDA     (acc),Y
00E0BE  1  AA           Le0be:  TAX
00E0BF  1  88                   DEY
00E0C0  1  B1 CE                LDA     (acc),Y
00E0C2  1  10 FA                BPL     Le0be
00E0C4  1  E0 C0                CPX     #$C0
00E0C6  1  B0 04                BCS     Le0cc
00E0C8  1  E0 00                CPX     #$00
00E0CA  1  30 F2                BMI     Le0be
00E0CC  1  AA           Le0cc:  TAX
00E0CD  1  68                   PLA
00E0CE  1  E9 01                SBC     #$01
00E0D0  1  D0 E9                BNE     Le0bb
00E0D2  1  24 E4                BIT     p2
00E0D4  1  30 03                BMI     Le0d9
00E0D6  1  20 F8 EF             JSR     Seff8
00E0D9  1  B1 CE        Le0d9:  LDA     (acc),Y
00E0DB  1  10 10                BPL     Le0ed
00E0DD  1  AA                   TAX
00E0DE  1  29 3F                AND     #$3F
00E0E0  1  85 E4                STA     p2
00E0E2  1  18                   CLC
00E0E3  1  69 A0                ADC     #$A0
00E0E5  1  20 C9 E3             JSR     cout
00E0E8  1  88                   DEY
00E0E9  1  E0 C0                CPX     #$C0
00E0EB  1  90 EC                BCC     Le0d9
00E0ED  1  20 0C E0     Le0ed:  JSR     Se00c
00E0F0  1  68                   PLA
00E0F1  1  C9 5D                CMP     #$5D
00E0F3  1  F0 A4                BEQ     Le099
00E0F5  1  C9 28                CMP     #$28
00E0F7  1  D0 8A                BNE     Le083
00E0F9  1  F0 9E                BEQ     Le099
00E0FB  1               
00E0FB  1               ; token $2A - left paren for substring like A$(3,5)
00E0FB  1  20 18 E1     paren_substr:   JSR     Se118
00E0FE  1  95 50                STA     noun_stk_l,X
00E100  1  D5 78                CMP     noun_stk_h_str,X
00E102  1  90 11        Le102:  BCC     Le115
00E104  1  A0 2B        string_err:     LDY     #$2B
00E106  1  4C E0 E3     go_errmess_1:   JMP     print_err_msg
00E109  1               
00E109  1               ; token $2B - comma for substring like A$(3,5)
00E109  1  20 34 EE     comma_substr:   JSR     getbyte
00E10C  1  D5 50                CMP     noun_stk_l,X
00E10E  1  90 F4                BCC     string_err
00E110  1  20 E4 EF             JSR     Sefe4
00E113  1  95 78                STA     noun_stk_h_str,X
00E115  1  4C 23 E8     Le115:  JMP     left_paren
00E118  1               
00E118  1  20 34 EE     Se118:  JSR     getbyte
00E11B  1  F0 E7                BEQ     string_err
00E11D  1  38                   SEC
00E11E  1  E9 01                SBC     #$01
00E120  1  60                   RTS
00E121  1               
00E121  1               ; token $42 - left paren for string array as dest
00E121  1               ; A$(1)="FOO"
00E121  1  20 18 E1     str_arr_dest:   JSR     Se118
00E124  1  95 50                STA     noun_stk_l,X
00E126  1  18                   CLC
00E127  1  F5 78                SBC     noun_stk_h_str,X
00E129  1  4C 02 E1             JMP     Le102
00E12C  1  A0 14        Le12c:  LDY     #$14
00E12E  1  D0 D6                BNE     go_errmess_1
00E130  1               
00E130  1               ; token $43 - comma, next var in DIM statement is string
00E130  1               ; token $4E - "DIM", next var in DIM is string
00E130  1  20 18 E1     dim_str:        JSR     Se118
00E133  1  E8                   INX
00E134  1  B5 50        Le134:  LDA     noun_stk_l,X
00E136  1  85 DA                STA     aux
00E138  1  65 CE                ADC     acc
00E13A  1  48                   PHA
00E13B  1  A8                   TAY
00E13C  1  B5 78                LDA     noun_stk_h_str,X
00E13E  1  85 DB                STA     aux+1
00E140  1  65 CF                ADC     acc+1
00E142  1  48                   PHA
00E143  1  C4 CA                CPY     pp
00E145  1  E5 CB                SBC     pp+1
00E147  1  B0 E3                BCS     Le12c
00E149  1  A5 DA                LDA     aux
00E14B  1  69 FE                ADC     #$FE
00E14D  1  85 DA                STA     aux
00E14F  1  A9 FF                LDA     #$FF
00E151  1  A8                   TAY
00E152  1  65 DB                ADC     aux+1
00E154  1  85 DB                STA     aux+1
00E156  1  C8           Le156:  INY
00E157  1  B1 DA                LDA     (aux),Y
00E159  1  D9 CC 00             CMP     pv,Y
00E15C  1  D0 0F                BNE     Le16d
00E15E  1  98                   TYA
00E15F  1  F0 F5                BEQ     Le156
00E161  1  68           Le161:  PLA
00E162  1  91 DA                STA     (aux),Y
00E164  1  99 CC 00             STA     pv,Y
00E167  1  88                   DEY
00E168  1  10 F7                BPL     Le161
00E16A  1  E8                   INX
00E16B  1  60                   RTS
00E16C  1  EA                   NOP
00E16D  1  A0 80        Le16d:  LDY     #$80
00E16F  1  D0 95        Le16f:  BNE     go_errmess_1
00E171  1               
00E171  1               ; token ???
00E171  1  A9 00        input_str:      LDA     #$00
00E173  1  20 0A E7             JSR     push_a_noun_stk
00E176  1  A0 02                LDY     #$02
00E178  1  94 78                STY     noun_stk_h_str,X
00E17A  1  20 0A E7             JSR     push_a_noun_stk
00E17D  1  A9 BF                LDA     #$BF                    ; '?'
00E17F  1  20 C9 E3             JSR     cout
00E182  1  A0 00                LDY     #$00
00E184  1  20 9E E2             JSR     read_line
00E187  1  94 78                STY     noun_stk_h_str,X
00E189  1  EA                   NOP
00E18A  1  EA                   NOP
00E18B  1  EA                   NOP
00E18C  1               
00E18C  1               ; token $70 - string literal
00E18C  1  B5 51        string_lit:     LDA     noun_stk_l+1,X
00E18E  1  85 CE                STA     acc
00E190  1  B5 79                LDA     noun_stk_h_str+1,X
00E192  1  85 CF                STA     acc+1
00E194  1  E8                   INX
00E195  1  E8                   INX
00E196  1  20 BC E1             JSR     Se1bc
00E199  1  B5 4E        Le199:  LDA     rnd,X
00E19B  1  D5 76                CMP     syn_stk_h+30,X
00E19D  1  B0 15                BCS     Le1b4
00E19F  1  F6 4E                INC     rnd,X
00E1A1  1  A8                   TAY
00E1A2  1  B1 CE                LDA     (acc),Y
00E1A4  1  B4 50                LDY     noun_stk_l,X
00E1A6  1  C4 E4                CPY     p2
00E1A8  1  90 04                BCC     Le1ae
00E1AA  1  A0 83                LDY     #$83
00E1AC  1  D0 C1                BNE     Le16f
00E1AE  1  91 DA        Le1ae:  STA     (aux),Y
00E1B0  1  F6 50                INC     noun_stk_l,X
00E1B2  1  90 E5                BCC     Le199
00E1B4  1  B4 50        Le1b4:  LDY     noun_stk_l,X
00E1B6  1  8A                   TXA
00E1B7  1  91 DA                STA     (aux),Y
00E1B9  1  E8                   INX
00E1BA  1  E8                   INX
00E1BB  1  60                   RTS
00E1BC  1               
00E1BC  1  B5 51        Se1bc:  LDA     noun_stk_l+1,X
00E1BE  1  85 DA                STA     aux
00E1C0  1  38                   SEC
00E1C1  1  E9 02                SBC     #$02
00E1C3  1  85 E4                STA     p2
00E1C5  1  B5 79                LDA     noun_stk_h_str+1,X
00E1C7  1  85 DB                STA     aux+1
00E1C9  1  E9 00                SBC     #$00
00E1CB  1  85 E5                STA     p2+1
00E1CD  1  A0 00                LDY     #$00
00E1CF  1  B1 E4                LDA     (p2),Y
00E1D1  1  18                   CLC
00E1D2  1  E5 DA                SBC     aux
00E1D4  1  85 E4                STA     p2
00E1D6  1  60                   RTS
00E1D7  1               
00E1D7  1               ; token $39 - "=" for string equality operator
00E1D7  1  B5 53        string_eq:      LDA     noun_stk_l+3,X
00E1D9  1  85 CE                STA     acc
00E1DB  1  B5 7B                LDA     noun_stk_h_str+3,X
00E1DD  1  85 CF                STA     acc+1
00E1DF  1  B5 51                LDA     noun_stk_l+1,X
00E1E1  1  85 DA                STA     aux
00E1E3  1  B5 79                LDA     noun_stk_h_str+1,X
00E1E5  1  85 DB                STA     aux+1
00E1E7  1  E8                   INX
00E1E8  1  E8                   INX
00E1E9  1  E8                   INX
00E1EA  1  A0 00                LDY     #$00
00E1EC  1  94 78                STY     noun_stk_h_str,X
00E1EE  1  94 A0                STY     noun_stk_h_int,X
00E1F0  1  C8                   INY
00E1F1  1  94 50                STY     noun_stk_l,X
00E1F3  1  B5 4D        Le1f3:  LDA     himem+1,X
00E1F5  1  D5 75                CMP     syn_stk_h+29,X
00E1F7  1  08                   PHP
00E1F8  1  48                   PHA
00E1F9  1  B5 4F                LDA     rnd+1,X
00E1FB  1  D5 77                CMP     syn_stk_h+31,X
00E1FD  1  90 07                BCC     Le206
00E1FF  1  68                   PLA
00E200  1  28                   PLP
00E201  1  B0 02                BCS     Le205
00E203  1  56 50        Le203:  LSR     noun_stk_l,X
00E205  1  60           Le205:  RTS
00E206  1  A8           Le206:  TAY
00E207  1  B1 CE                LDA     (acc),Y
00E209  1  85 E4                STA     p2
00E20B  1  68                   PLA
00E20C  1  A8                   TAY
00E20D  1  28                   PLP
00E20E  1  B0 F3                BCS     Le203
00E210  1  B1 DA                LDA     (aux),Y
00E212  1  C5 E4                CMP     p2
00E214  1  D0 ED                BNE     Le203
00E216  1  F6 4F                INC     rnd+1,X
00E218  1  F6 4D                INC     himem+1,X
00E21A  1  B0 D7                BCS     Le1f3
00E21C  1               
00E21C  1               ; token $3A - "#" for string inequality operator
00E21C  1  20 D7 E1     string_neq:     JSR     string_eq
00E21F  1  4C 36 E7             JMP     not_op
00E222  1               
00E222  1               ; token $14 - "*" for numeric multiplication
00E222  1  20 54 E2     mult_op:        JSR     Se254
00E225  1  06 CE        Le225:  ASL     acc
00E227  1  26 CF                ROL     acc+1
00E229  1  90 0D                BCC     Le238
00E22B  1  18                   CLC
00E22C  1  A5 E6                LDA     p3
00E22E  1  65 DA                ADC     aux
00E230  1  85 E6                STA     p3
00E232  1  A5 E7                LDA     p3+1
00E234  1  65 DB                ADC     aux+1
00E236  1  85 E7                STA     p3+1
00E238  1  88           Le238:  DEY
00E239  1  F0 09                BEQ     Le244
00E23B  1  06 E6                ASL     p3
00E23D  1  26 E7                ROL     p3+1
00E23F  1  10 E4                BPL     Le225
00E241  1  4C 7E E7             JMP     Le77e
00E244  1  A5 E6        Le244:  LDA     p3
00E246  1  20 08 E7             JSR     push_ya_noun_stk
00E249  1  A5 E7                LDA     p3+1
00E24B  1  95 A0                STA     noun_stk_h_int,X
00E24D  1  06 E5                ASL     p2+1
00E24F  1  90 28                BCC     Le279
00E251  1  4C 6F E7             JMP     negate
00E254  1               
00E254  1  A9 55        Se254:  LDA     #$55
00E256  1  85 E5                STA     p2+1
00E258  1  20 5B E2             JSR     Se25b
00E25B  1               
00E25B  1  A5 CE        Se25b:  LDA     acc
00E25D  1  85 DA                STA     aux
00E25F  1  A5 CF                LDA     acc+1
00E261  1  85 DB                STA     aux+1
00E263  1  20 15 E7             JSR     get16bit
00E266  1  84 E6                STY     p3
00E268  1  84 E7                STY     p3+1
00E26A  1  A5 CF                LDA     acc+1
00E26C  1  10 09                BPL     Le277
00E26E  1  CA                   DEX
00E26F  1  06 E5                ASL     p2+1
00E271  1  20 6F E7             JSR     negate
00E274  1  20 15 E7             JSR     get16bit
00E277  1  A0 10        Le277:  LDY     #$10
00E279  1  60           Le279:  RTS
00E27A  1               
00E27A  1               ; token $1f - "MOD"
00E27A  1  20 6C EE     mod_op: JSR     See6c
00E27D  1  F0 C5                BEQ     Le244
00E27F  1  FF                   .byte   $FF
00E280  1  C9 84        Le280:  CMP     #$84
00E282  1  D0 02                BNE     Le286
00E284  1  46 F8                LSR     auto_flag
00E286  1  C9 DF        Le286:  CMP     #$DF
00E288  1  F0 11                BEQ     Le29b
00E28A  1  C9 9B                CMP     #$9B
00E28C  1  F0 06                BEQ     Le294
00E28E  1  99 00 02             STA     buffer,Y
00E291  1  C8                   INY
00E292  1  10 0A                BPL     read_line
00E294  1  A0 8B        Le294:  LDY     #$8B
00E296  1  20 C4 E3             JSR     Se3c4
00E299  1               
00E299  1  A0 01        Se299:  LDY     #$01
00E29B  1  88           Le29b:  DEY
00E29C  1  30 F6                BMI     Le294
00E29E  1               
00E29E  1               ; read a line from keyboard (using rdkey) into buffer
00E29E  1  20 03 E0     read_line:      JSR     rdkey
00E2A1  1  EA                   NOP
00E2A2  1  EA                   NOP
00E2A3  1  20 C9 E3             JSR     cout
00E2A6  1  C9 8D                CMP     #$8D
00E2A8  1  D0 D6                BNE     Le280
00E2AA  1  A9 DF                LDA     #$DF
00E2AC  1  99 00 02             STA     buffer,Y
00E2AF  1  60                   RTS
00E2B0  1  20 D3 EF     cold:   JSR     mem_init_4k
00E2B3  1                       .export warm
00E2B3  1  20 CD E3     warm:   JSR     crout           ; BASIC warm start entry point
00E2B6  1  46 D9        Le2b6:  LSR     run_flag
00E2B8  1  A9 BE                LDA     #'>'+$80        ; Prompt character (high bit set)
00E2BA  1  20 C9 E3             JSR     cout
00E2BD  1  A0 00                LDY     #$00
00E2BF  1  84 FA                STY     leadzr
00E2C1  1  24 F8                BIT     auto_flag
00E2C3  1  10 0C                BPL     Le2d1
00E2C5  1  A6 F6                LDX     auto_ln
00E2C7  1  A5 F7                LDA     auto_ln+1
00E2C9  1  20 1B E5             JSR     prdec
00E2CC  1  A9 A0                LDA     #$A0
00E2CE  1  20 C9 E3             JSR     cout
00E2D1  1  A2 FF        Le2d1:  LDX     #$FF
00E2D3  1  9A                   TXS
00E2D4  1  20 9E E2             JSR     read_line
00E2D7  1  84 F1                STY     token_index
00E2D9  1  8A                   TXA
00E2DA  1  85 C8                STA     text_index
00E2DC  1  A2 20                LDX     #$20
00E2DE  1  20 91 E4             JSR     Se491
00E2E1  1  A5 C8                LDA     text_index
00E2E3  1  69 00                ADC     #$00
00E2E5  1  85 E0                STA     pverb
00E2E7  1  A9 00                LDA     #$00
00E2E9  1  AA                   TAX
00E2EA  1  69 02                ADC     #$02
00E2EC  1  85 E1                STA     pverb+1
00E2EE  1  A1 E0                LDA     (pverb,X)
00E2F0  1  29 F0                AND     #$F0
00E2F2  1  C9 B0                CMP     #$B0
00E2F4  1  F0 03                BEQ     Le2f9
00E2F6  1  4C 83 E8             JMP     Le883
00E2F9  1  A0 02        Le2f9:  LDY     #$02
00E2FB  1  B1 E0        Le2fb:  LDA     (pverb),Y
00E2FD  1  99 CD 00             STA     pv+1,Y
00E300  1  88                   DEY
00E301  1  D0 F8                BNE     Le2fb
00E303  1  20 8A E3             JSR     Se38a
00E306  1  A5 F1                LDA     token_index
00E308  1  E5 C8                SBC     text_index
00E30A  1  C9 04                CMP     #$04
00E30C  1  F0 A8                BEQ     Le2b6
00E30E  1  91 E0                STA     (pverb),Y
00E310  1  A5 CA                LDA     pp
00E312  1  F1 E0                SBC     (pverb),Y
00E314  1  85 E4                STA     p2
00E316  1  A5 CB                LDA     pp+1
00E318  1  E9 00                SBC     #$00
00E31A  1  85 E5                STA     p2+1
00E31C  1  A5 E4                LDA     p2
00E31E  1  C5 CC                CMP     pv
00E320  1  A5 E5                LDA     p2+1
00E322  1  E5 CD                SBC     pv+1
00E324  1  90 45                BCC     Le36b
00E326  1  A5 CA        Le326:  LDA     pp
00E328  1  F1 E0                SBC     (pverb),Y
00E32A  1  85 E6                STA     p3
00E32C  1  A5 CB                LDA     pp+1
00E32E  1  E9 00                SBC     #$00
00E330  1  85 E7                STA     p3+1
00E332  1  B1 CA                LDA     (pp),Y
00E334  1  91 E6                STA     (p3),Y
00E336  1  E6 CA                INC     pp
00E338  1  D0 02                BNE     Le33c
00E33A  1  E6 CB                INC     pp+1
00E33C  1  A5 E2        Le33c:  LDA     p1
00E33E  1  C5 CA                CMP     pp
00E340  1  A5 E3                LDA     p1+1
00E342  1  E5 CB                SBC     pp+1
00E344  1  B0 E0                BCS     Le326
00E346  1  B5 E4        Le346:  LDA     p2,X
00E348  1  95 CA                STA     pp,X
00E34A  1  CA                   DEX
00E34B  1  10 F9                BPL     Le346
00E34D  1  B1 E0                LDA     (pverb),Y
00E34F  1  A8                   TAY
00E350  1  88           Le350:  DEY
00E351  1  B1 E0                LDA     (pverb),Y
00E353  1  91 E6                STA     (p3),Y
00E355  1  98                   TYA
00E356  1  D0 F8                BNE     Le350
00E358  1  24 F8                BIT     auto_flag
00E35A  1  10 09                BPL     Le365
00E35C  1  B5 F7        Le35c:  LDA     auto_ln+1,X
00E35E  1  75 F5                ADC     auto_inc+1,X
00E360  1  95 F7                STA     auto_ln+1,X
00E362  1  E8                   INX
00E363  1  F0 F7                BEQ     Le35c
00E365  1  10 7E        Le365:  BPL     Le3e5
00E367  1  00 00 00 00          .byte   $00,$00,$00,$00
00E36B  1  A0 14        Le36b:  LDY     #$14
00E36D  1  D0 71                BNE     print_err_msg
00E36F  1               
00E36F  1               ; token $0a - "," in DEL command
00E36F  1  20 15 E7     del_comma:      JSR     get16bit
00E372  1  A5 E2                LDA     p1
00E374  1  85 E6                STA     p3
00E376  1  A5 E3                LDA     p1+1
00E378  1  85 E7                STA     p3+1
00E37A  1  20 75 E5             JSR     find_line1
00E37D  1  A5 E2                LDA     p1
00E37F  1  85 E4                STA     p2
00E381  1  A5 E3                LDA     p1+1
00E383  1  85 E5                STA     p2+1
00E385  1  D0 0E                BNE     Le395
00E387  1               
00E387  1               ; token $09 - "DEL"
00E387  1  20 15 E7     del_cmd:        JSR     get16bit
00E38A  1               
00E38A  1  20 6D E5     Se38a:  JSR     find_line
00E38D  1  A5 E6                LDA     p3
00E38F  1  85 E2                STA     p1
00E391  1  A5 E7                LDA     p3+1
00E393  1  85 E3                STA     p1+1
00E395  1  A0 00        Le395:  LDY     #$00
00E397  1  A5 CA        Le397:  LDA     pp
00E399  1  C5 E4                CMP     p2
00E39B  1  A5 CB                LDA     pp+1
00E39D  1  E5 E5                SBC     p2+1
00E39F  1  B0 16                BCS     Le3b7
00E3A1  1  A5 E4                LDA     p2
00E3A3  1  D0 02                BNE     Le3a7
00E3A5  1  C6 E5                DEC     p2+1
00E3A7  1  C6 E4        Le3a7:  DEC     p2
00E3A9  1  A5 E6                LDA     p3
00E3AB  1  D0 02                BNE     Le3af
00E3AD  1  C6 E7                DEC     p3+1
00E3AF  1  C6 E6        Le3af:  DEC     p3
00E3B1  1  B1 E4                LDA     (p2),Y
00E3B3  1  91 E6                STA     (p3),Y
00E3B5  1  90 E0                BCC     Le397
00E3B7  1  A5 E6        Le3b7:  LDA     p3
00E3B9  1  85 CA                STA     pp
00E3BB  1  A5 E7                LDA     p3+1
00E3BD  1  85 CB                STA     pp+1
00E3BF  1  60                   RTS
00E3C0  1  20 C9 E3     Le3c0:  JSR     cout
00E3C3  1  C8                   INY
00E3C4  1               
00E3C4  1  B9 00 EB     Se3c4:  LDA     error_msg_tbl,Y
00E3C7  1  30 F7                BMI     Le3c0
00E3C9  1               
00E3C9  1  C9 8D        cout:   CMP     #$8D
00E3CB  1  D0 06                BNE     Le3d3
00E3CD  1               
00E3CD  1  A9 00        crout:  LDA     #$00            ; character output
00E3CF  1  85 24                STA     ch
00E3D1  1  A9 8D                LDA     #$8D
00E3D3  1  E6 24        Le3d3:  INC     ch
00E3D5  1               
00E3D5  1               ; Send character to display. Char is in A.
00E3D5  1  2C 12 D0     Le3d5:  BIT     DSP          ; See if display ready
00E3D8  1  30 FB                BMI     Le3d5        ; Loop if not
00E3DA  1  8D 12 D0             STA     DSP          ; Write display data
00E3DD  1  60                   RTS                  ; and return
00E3DE  1               
00E3DE  1  A0 06        too_long_err:   LDY     #$06
00E3E0  1               
00E3E0  1  20 D3 EE     print_err_msg:  JSR     print_err_msg1  ; print error message specified in Y
00E3E3  1  24 D9                BIT     run_flag
00E3E5  1  30 03        Le3e5:  BMI     Le3ea
00E3E7  1  4C B6 E2             JMP     Le2b6
00E3EA  1  4C 9A EB     Le3ea:  JMP     Leb9a
00E3ED  1  2A           Le3ed:  ROL
00E3EE  1  69 A0                ADC     #$A0
00E3F0  1  DD 00 02             CMP     buffer,X
00E3F3  1  D0 53                BNE     Le448
00E3F5  1  B1 FE                LDA     (synpag),Y
00E3F7  1  0A                   ASL
00E3F8  1  30 06                BMI     Le400
00E3FA  1  88                   DEY
00E3FB  1  B1 FE                LDA     (synpag),Y
00E3FD  1  30 29                BMI     Le428
00E3FF  1  C8                   INY
00E400  1  86 C8        Le400:  STX     text_index
00E402  1  98                   TYA
00E403  1  48                   PHA
00E404  1  A2 00                LDX     #$00
00E406  1  A1 FE                LDA     (synpag,X)
00E408  1  AA                   TAX
00E409  1  4A           Le409:  LSR
00E40A  1  49 48                EOR     #$48
00E40C  1  11 FE                ORA     (synpag),Y
00E40E  1  C9 C0                CMP     #$C0
00E410  1  90 01                BCC     Le413
00E412  1  E8                   INX
00E413  1  C8           Le413:  INY
00E414  1  D0 F3                BNE     Le409
00E416  1  68                   PLA
00E417  1  A8                   TAY
00E418  1  8A                   TXA
00E419  1  4C C0 E4             JMP     Le4c0
00E41C  1               
00E41C  1               ; write a token to the buffer
00E41C  1               ; buffer [++tokndx] = A
00E41C  1  E6 F1        put_token:      INC     token_index
00E41E  1  A6 F1                LDX     token_index
00E420  1  F0 BC                BEQ     too_long_err
00E422  1  9D 00 02             STA     buffer,X
00E425  1  60           Le425:  RTS
00E426  1  A6 C8        Le426:  LDX     text_index
00E428  1  A9 A0        Le428:  LDA     #$A0
00E42A  1  E8           Le42a:  INX
00E42B  1  DD 00 02             CMP     buffer,X
00E42E  1  B0 FA                BCS     Le42a
00E430  1  B1 FE                LDA     (synpag),Y
00E432  1  29 3F                AND     #$3F
00E434  1  4A                   LSR
00E435  1  D0 B6                BNE     Le3ed
00E437  1  BD 00 02             LDA     buffer,X
00E43A  1  B0 06                BCS     Le442
00E43C  1  69 3F                ADC     #$3F
00E43E  1  C9 1A                CMP     #$1A
00E440  1  90 6F                BCC     Le4b1
00E442  1  69 4F        Le442:  ADC     #$4F
00E444  1  C9 0A                CMP     #$0A
00E446  1  90 69                BCC     Le4b1
00E448  1  A6 FD        Le448:  LDX     synstkdx
00E44A  1  C8           Le44a:  INY
00E44B  1  B1 FE                LDA     (synpag),Y
00E44D  1  29 E0                AND     #$E0
00E44F  1  C9 20                CMP     #$20
00E451  1  F0 7A                BEQ     Le4cd
00E453  1  B5 A8                LDA     txtndxstk,X
00E455  1  85 C8                STA     text_index
00E457  1  B5 D1                LDA     tokndxstk,X
00E459  1  85 F1                STA     token_index
00E45B  1  88           Le45b:  DEY
00E45C  1  B1 FE                LDA     (synpag),Y
00E45E  1  0A                   ASL
00E45F  1  10 FA                BPL     Le45b
00E461  1  88                   DEY
00E462  1  B0 38                BCS     Le49c
00E464  1  0A                   ASL
00E465  1  30 35                BMI     Le49c
00E467  1  B4 58                LDY     syn_stk_h,X
00E469  1  84 FF                STY     synpag+1
00E46B  1  B4 80                LDY     syn_stk_l,X
00E46D  1  E8                   INX
00E46E  1  10 DA                BPL     Le44a
00E470  1  F0 B3        Le470:  BEQ     Le425
00E472  1  C9 7E                CMP     #$7E
00E474  1  B0 22                BCS     Le498
00E476  1  CA                   DEX
00E477  1  10 04                BPL     Le47d
00E479  1  A0 06                LDY     #$06
00E47B  1  10 29                BPL     go_errmess_2
00E47D  1  94 80        Le47d:  STY     syn_stk_l,X
00E47F  1  A4 FF                LDY     synpag+1
00E481  1  94 58                STY     syn_stk_h,X
00E483  1  A4 C8                LDY     text_index
00E485  1  94 A8                STY     txtndxstk,X
00E487  1  A4 F1                LDY     token_index
00E489  1  94 D1                STY     tokndxstk,X
00E48B  1  29 1F                AND     #$1F
00E48D  1  A8                   TAY
00E48E  1  B9 20 EC             LDA     syntabl_index,Y
00E491  1               
00E491  1  0A           Se491:  ASL
00E492  1  A8                   TAY
00E493  1  A9 76                LDA     #$76
00E495  1  2A                   ROL
00E496  1  85 FF                STA     synpag+1
00E498  1  D0 01        Le498:  BNE     Le49b
00E49A  1  C8                   INY
00E49B  1  C8           Le49b:  INY
00E49C  1  86 FD        Le49c:  STX     synstkdx
00E49E  1  B1 FE                LDA     (synpag),Y
00E4A0  1  30 84                BMI     Le426
00E4A2  1  D0 05                BNE     Le4a9
00E4A4  1  A0 0E                LDY     #$0E
00E4A6  1  4C E0 E3     go_errmess_2:   JMP     print_err_msg
00E4A9  1  C9 03        Le4a9:  CMP     #$03
00E4AB  1  B0 C3                BCS     Le470
00E4AD  1  4A                   LSR
00E4AE  1  A6 C8                LDX     text_index
00E4B0  1  E8                   INX
00E4B1  1  BD 00 02     Le4b1:  LDA     buffer,X
00E4B4  1  90 04                BCC     Le4ba
00E4B6  1  C9 A2                CMP     #$A2
00E4B8  1  F0 0A                BEQ     Le4c4
00E4BA  1  C9 DF        Le4ba:  CMP     #$DF
00E4BC  1  F0 06                BEQ     Le4c4
00E4BE  1  86 C8                STX     text_index
00E4C0  1  20 1C E4     Le4c0:  JSR     put_token
00E4C3  1  C8                   INY
00E4C4  1  88           Le4c4:  DEY
00E4C5  1  A6 FD                LDX     synstkdx
00E4C7  1  B1 FE        Le4c7:  LDA     (synpag),Y
00E4C9  1  88                   DEY
00E4CA  1  0A                   ASL
00E4CB  1  10 CF                BPL     Le49c
00E4CD  1  B4 58        Le4cd:  LDY     syn_stk_h,X
00E4CF  1  84 FF                STY     synpag+1
00E4D1  1  B4 80                LDY     syn_stk_l,X
00E4D3  1  E8                   INX
00E4D4  1  B1 FE                LDA     (synpag),Y
00E4D6  1  29 9F                AND     #$9F
00E4D8  1  D0 ED                BNE     Le4c7
00E4DA  1  85 F2                STA     pcon
00E4DC  1  85 F3                STA     pcon+1
00E4DE  1  98                   TYA
00E4DF  1  48                   PHA
00E4E0  1  86 FD                STX     synstkdx
00E4E2  1  B4 D0                LDY     srch,X
00E4E4  1  84 C9                STY     leadbl
00E4E6  1  18                   CLC
00E4E7  1  A9 0A        Le4e7:  LDA     #$0A
00E4E9  1  85 F9                STA     char
00E4EB  1  A2 00                LDX     #$00
00E4ED  1  C8                   INY
00E4EE  1  B9 00 02             LDA     buffer,Y
00E4F1  1  29 0F                AND     #$0F
00E4F3  1  65 F2        Le4f3:  ADC     pcon
00E4F5  1  48                   PHA
00E4F6  1  8A                   TXA
00E4F7  1  65 F3                ADC     pcon+1
00E4F9  1  30 1C                BMI     Le517
00E4FB  1  AA                   TAX
00E4FC  1  68                   PLA
00E4FD  1  C6 F9                DEC     char
00E4FF  1  D0 F2                BNE     Le4f3
00E501  1  85 F2                STA     pcon
00E503  1  86 F3                STX     pcon+1
00E505  1  C4 F1                CPY     token_index
00E507  1  D0 DE                BNE     Le4e7
00E509  1  A4 C9                LDY     leadbl
00E50B  1  C8                   INY
00E50C  1  84 F1                STY     token_index
00E50E  1  20 1C E4             JSR     put_token
00E511  1  68                   PLA
00E512  1  A8                   TAY
00E513  1  A5 F3                LDA     pcon+1
00E515  1  B0 A9                BCS     Le4c0
00E517  1  A0 00        Le517:  LDY     #$00
00E519  1  10 8B                BPL     go_errmess_2
00E51B  1               
00E51B  1  85 F3        prdec:  STA     pcon+1  ; output A:X in decimal
00E51D  1  86 F2                STX     pcon
00E51F  1  A2 04                LDX     #$04
00E521  1  86 C9                STX     leadbl
00E523  1  A9 B0        Le523:  LDA     #$B0
00E525  1  85 F9                STA     char
00E527  1  A5 F2        Le527:  LDA     pcon
00E529  1  DD 63 E5             CMP     dectabl,X
00E52C  1  A5 F3                LDA     pcon+1
00E52E  1  FD 68 E5             SBC     dectabh,X
00E531  1  90 0D                BCC     Le540
00E533  1  85 F3                STA     pcon+1
00E535  1  A5 F2                LDA     pcon
00E537  1  FD 63 E5             SBC     dectabl,X
00E53A  1  85 F2                STA     pcon
00E53C  1  E6 F9                INC     char
00E53E  1  D0 E7                BNE     Le527
00E540  1  A5 F9        Le540:  LDA     char
00E542  1  E8                   INX
00E543  1  CA                   DEX
00E544  1  F0 0E                BEQ     Le554
00E546  1  C9 B0                CMP     #$B0
00E548  1  F0 02                BEQ     Le54c
00E54A  1  85 C9                STA     leadbl
00E54C  1  24 C9        Le54c:  BIT     leadbl
00E54E  1  30 04                BMI     Le554
00E550  1  A5 FA                LDA     leadzr
00E552  1  F0 0B                BEQ     Le55f
00E554  1  20 C9 E3     Le554:  JSR     cout
00E557  1  24 F8                BIT     auto_flag
00E559  1  10 04                BPL     Le55f
00E55B  1  99 00 02             STA     buffer,Y
00E55E  1  C8                   INY
00E55F  1  CA           Le55f:  DEX
00E560  1  10 C1                BPL     Le523
00E562  1  60                   RTS
00E563  1               ; powers of 10 table, low byte
00E563  1  01 0A 64 E8  dectabl:        .byte   $01,$0A,$64,$E8,$10             ; "..dh."
00E567  1  10           
00E568  1               
00E568  1               ; powers of 10 table, high byte
00E568  1  00 00 00 03  dectabh:        .byte   $00,$00,$00,$03,$27             ; "....'"
00E56C  1  27           
00E56D  1               
00E56D  1  A5 CA        find_line:      LDA     pp
00E56F  1  85 E6                STA     p3
00E571  1  A5 CB                LDA     pp+1
00E573  1  85 E7                STA     p3+1
00E575  1               
00E575  1  E8           find_line1:     INX
00E576  1               
00E576  1  A5 E7        find_line2:     LDA     p3+1
00E578  1  85 E5                STA     p2+1
00E57A  1  A5 E6                LDA     p3
00E57C  1  85 E4                STA     p2
00E57E  1  C5 4C                CMP     himem
00E580  1  A5 E5                LDA     p2+1
00E582  1  E5 4D                SBC     himem+1
00E584  1  B0 26                BCS     Le5ac
00E586  1  A0 01                LDY     #$01
00E588  1  B1 E4                LDA     (p2),Y
00E58A  1  E5 CE                SBC     acc
00E58C  1  C8                   INY
00E58D  1  B1 E4                LDA     (p2),Y
00E58F  1  E5 CF                SBC     acc+1
00E591  1  B0 19                BCS     Le5ac
00E593  1  A0 00                LDY     #$00
00E595  1  A5 E6                LDA     p3
00E597  1  71 E4                ADC     (p2),Y
00E599  1  85 E6                STA     p3
00E59B  1  90 03                BCC     Le5a0
00E59D  1  E6 E7                INC     p3+1
00E59F  1  18                   CLC
00E5A0  1  C8           Le5a0:  INY
00E5A1  1  A5 CE                LDA     acc
00E5A3  1  F1 E4                SBC     (p2),Y
00E5A5  1  C8                   INY
00E5A6  1  A5 CF                LDA     acc+1
00E5A8  1  F1 E4                SBC     (p2),Y
00E5AA  1  B0 CA                BCS     find_line2
00E5AC  1  60           Le5ac:  RTS
00E5AD  1               
00E5AD  1               ; token $0B - "NEW"
00E5AD  1  46 F8        new_cmd:        LSR     auto_flag
00E5AF  1  A5 4C                LDA     himem
00E5B1  1  85 CA                STA     pp
00E5B3  1  A5 4D                LDA     himem+1
00E5B5  1  85 CB                STA     pp+1
00E5B7  1               
00E5B7  1               ; token $0C - "CLR"
00E5B7  1  A5 4A        clr:    LDA     lomem
00E5B9  1  85 CC                STA     pv
00E5BB  1  A5 4B                LDA     lomem+1
00E5BD  1  85 CD                STA     pv+1
00E5BF  1  A9 00                LDA     #$00
00E5C1  1  85 FB                STA     for_nest_count
00E5C3  1  85 FC                STA     gosub_nest_count
00E5C5  1  85 FE                STA     synpag
00E5C7  1  A9 00                LDA     #$00
00E5C9  1  85 1D                STA     Z1d
00E5CB  1  60                   RTS
00E5CC  1  A5 D0        Le5cc:  LDA     srch
00E5CE  1  69 05                ADC     #$05
00E5D0  1  85 D2                STA     srch2
00E5D2  1  A5 D1                LDA     tokndxstk
00E5D4  1  69 00                ADC     #$00
00E5D6  1  85 D3                STA     srch2+1
00E5D8  1  A5 D2                LDA     srch2
00E5DA  1  C5 CA                CMP     pp
00E5DC  1  A5 D3                LDA     srch2+1
00E5DE  1  E5 CB                SBC     pp+1
00E5E0  1  90 03                BCC     Le5e5
00E5E2  1  4C 6B E3             JMP     Le36b
00E5E5  1  A5 CE        Le5e5:  LDA     acc
00E5E7  1  91 D0                STA     (srch),Y
00E5E9  1  A5 CF                LDA     acc+1
00E5EB  1  C8                   INY
00E5EC  1  91 D0                STA     (srch),Y
00E5EE  1  A5 D2                LDA     srch2
00E5F0  1  C8                   INY
00E5F1  1  91 D0                STA     (srch),Y
00E5F3  1  A5 D3                LDA     srch2+1
00E5F5  1  C8                   INY
00E5F6  1  91 D0                STA     (srch),Y
00E5F8  1  A9 00                LDA     #$00
00E5FA  1  C8                   INY
00E5FB  1  91 D0                STA     (srch),Y
00E5FD  1  C8                   INY
00E5FE  1  91 D0                STA     (srch),Y
00E600  1  A5 D2                LDA     srch2
00E602  1  85 CC                STA     pv
00E604  1  A5 D3                LDA     srch2+1
00E606  1  85 CD                STA     pv+1
00E608  1  A5 D0                LDA     srch
00E60A  1  90 43                BCC     Le64f
00E60C  1  85 CE        execute_var:    STA     acc
00E60E  1  84 CF                STY     acc+1
00E610  1  20 FF E6             JSR     get_next_prog_byte
00E613  1  30 0E                BMI     Le623
00E615  1  C9 40                CMP     #$40
00E617  1  F0 0A                BEQ     Le623
00E619  1  4C 28 E6             JMP     Le628
00E61C  1  06 C9 49 D0          .byte   $06,$C9,$49,$D0,$07,$A9,$49
00E620  1  07 A9 49     
00E623  1  85 CF        Le623:  STA     acc+1
00E625  1  20 FF E6             JSR     get_next_prog_byte
00E628  1  A5 4B        Le628:  LDA     lomem+1
00E62A  1  85 D1                STA     tokndxstk
00E62C  1  A5 4A                LDA     lomem
00E62E  1  85 D0        Le62e:  STA     srch
00E630  1  C5 CC                CMP     pv
00E632  1  A5 D1                LDA     tokndxstk
00E634  1  E5 CD                SBC     pv+1
00E636  1  B0 94                BCS     Le5cc
00E638  1  B1 D0                LDA     (srch),Y
00E63A  1  C8                   INY
00E63B  1  C5 CE                CMP     acc
00E63D  1  D0 06                BNE     Le645
00E63F  1  B1 D0                LDA     (srch),Y
00E641  1  C5 CF                CMP     acc+1
00E643  1  F0 0E                BEQ     Le653
00E645  1  C8           Le645:  INY
00E646  1  B1 D0                LDA     (srch),Y
00E648  1  48                   PHA
00E649  1  C8                   INY
00E64A  1  B1 D0                LDA     (srch),Y
00E64C  1  85 D1                STA     tokndxstk
00E64E  1  68                   PLA
00E64F  1  A0 00        Le64f:  LDY     #$00
00E651  1  F0 DB                BEQ     Le62e
00E653  1  A5 D0        Le653:  LDA     srch
00E655  1  69 03                ADC     #$03
00E657  1  20 0A E7             JSR     push_a_noun_stk
00E65A  1  A5 D1                LDA     tokndxstk
00E65C  1  69 00                ADC     #$00
00E65E  1  95 78                STA     noun_stk_h_str,X
00E660  1  A5 CF                LDA     acc+1
00E662  1  C9 40                CMP     #$40
00E664  1  D0 1C                BNE     fetch_prog_byte
00E666  1  88                   DEY
00E667  1  98                   TYA
00E668  1  20 0A E7             JSR     push_a_noun_stk
00E66B  1  88                   DEY
00E66C  1  94 78                STY     noun_stk_h_str,X
00E66E  1  A0 03                LDY     #$03
00E670  1  F6 78        Le670:  INC     noun_stk_h_str,X
00E672  1  C8                   INY
00E673  1  B1 D0                LDA     (srch),Y
00E675  1  30 F9                BMI     Le670
00E677  1  10 09                BPL     fetch_prog_byte
00E679  1               
00E679  1  A9 00        execute_stmt:   LDA     #$00
00E67B  1  85 D4                STA     if_flag
00E67D  1  85 D5                STA     cr_flag
00E67F  1  A2 20                LDX     #$20
00E681  1               
00E681  1               ; push old verb on stack for later use in precedence test
00E681  1  48           push_old_verb:  PHA
00E682  1  A0 00        fetch_prog_byte:        LDY     #$00
00E684  1  B1 E0                LDA     (pverb),Y
00E686  1  10 18        Le686:  BPL     execute_token
00E688  1  0A                   ASL
00E689  1  30 81                BMI     execute_var
00E68B  1  20 FF E6             JSR     get_next_prog_byte
00E68E  1  20 08 E7             JSR     push_ya_noun_stk
00E691  1  20 FF E6             JSR     get_next_prog_byte
00E694  1  95 A0                STA     noun_stk_h_int,X
00E696  1  24 D4        Le696:  BIT     if_flag
00E698  1  10 01                BPL     Le69b
00E69A  1  CA                   DEX
00E69B  1  20 FF E6     Le69b:  JSR     get_next_prog_byte
00E69E  1  B0 E6                BCS     Le686
00E6A0  1               
00E6A0  1  C9 28        execute_token:  CMP     #$28
00E6A2  1  D0 1F                BNE     execute_verb
00E6A4  1  A5 E0                LDA     pverb
00E6A6  1  20 0A E7             JSR     push_a_noun_stk
00E6A9  1  A5 E1                LDA     pverb+1
00E6AB  1  95 78                STA     noun_stk_h_str,X
00E6AD  1  24 D4                BIT     if_flag
00E6AF  1  30 0B                BMI     Le6bc
00E6B1  1  A9 01                LDA     #$01
00E6B3  1  20 0A E7             JSR     push_a_noun_stk
00E6B6  1  A9 00                LDA     #$00
00E6B8  1  95 78                STA     noun_stk_h_str,X
00E6BA  1  F6 78        Le6ba:  INC     noun_stk_h_str,X
00E6BC  1  20 FF E6     Le6bc:  JSR     get_next_prog_byte
00E6BF  1  30 F9                BMI     Le6ba
00E6C1  1  B0 D3                BCS     Le696
00E6C3  1  24 D4        execute_verb:   BIT     if_flag
00E6C5  1  10 06                BPL     Le6cd
00E6C7  1  C9 04                CMP     #$04
00E6C9  1  B0 D0                BCS     Le69b
00E6CB  1  46 D4                LSR     if_flag
00E6CD  1  A8           Le6cd:  TAY
00E6CE  1  85 D6                STA     current_verb
00E6D0  1  B9 98 E9             LDA     verb_prec_tbl,Y
00E6D3  1  29 55                AND     #$55
00E6D5  1  0A                   ASL
00E6D6  1  85 D7                STA     precedence
00E6D8  1  68           Le6d8:  PLA
00E6D9  1  A8                   TAY
00E6DA  1  B9 98 E9             LDA     verb_prec_tbl,Y
00E6DD  1  29 AA                AND     #$AA
00E6DF  1  C5 D7                CMP     precedence
00E6E1  1  B0 09                BCS     do_verb
00E6E3  1  98                   TYA
00E6E4  1  48                   PHA
00E6E5  1  20 FF E6             JSR     get_next_prog_byte
00E6E8  1  A5 D6                LDA     current_verb
00E6EA  1  90 95                BCC     push_old_verb
00E6EC  1  B9 10 EA     do_verb:        LDA     verb_adr_l,Y
00E6EF  1  85 CE                STA     acc
00E6F1  1  B9 88 EA             LDA     verb_adr_h,Y
00E6F4  1  85 CF                STA     acc+1
00E6F6  1  20 FC E6             JSR     Se6fc
00E6F9  1  4C D8 E6             JMP     Le6d8
00E6FC  1               
00E6FC  1  6C CE 00     Se6fc:  JMP     (acc)
00E6FF  1               
00E6FF  1  E6 E0        get_next_prog_byte:     INC     pverb
00E701  1  D0 02                BNE     Le705
00E703  1  E6 E1                INC     pverb+1
00E705  1  B1 E0        Le705:  LDA     (pverb),Y
00E707  1  60                   RTS
00E708  1               
00E708  1  94 77        push_ya_noun_stk:       STY     syn_stk_h+31,X
00E70A  1               
00E70A  1  CA           push_a_noun_stk:        DEX
00E70B  1  30 03                BMI     Le710
00E70D  1  95 50                STA     noun_stk_l,X
00E70F  1  60                   RTS
00E710  1  A0 66        Le710:  LDY     #$66
00E712  1  4C E0 E3     go_errmess_3:   JMP     print_err_msg
00E715  1               
00E715  1  A0 00        get16bit:       LDY     #$00
00E717  1  B5 50                LDA     noun_stk_l,X
00E719  1  85 CE                STA     acc
00E71B  1  B5 A0                LDA     noun_stk_h_int,X
00E71D  1  85 CF                STA     acc+1
00E71F  1  B5 78                LDA     noun_stk_h_str,X
00E721  1  F0 0E                BEQ     Le731
00E723  1  85 CF                STA     acc+1
00E725  1  B1 CE                LDA     (acc),Y
00E727  1  48                   PHA
00E728  1  C8                   INY
00E729  1  B1 CE                LDA     (acc),Y
00E72B  1  85 CF                STA     acc+1
00E72D  1  68                   PLA
00E72E  1  85 CE                STA     acc
00E730  1  88                   DEY
00E731  1  E8           Le731:  INX
00E732  1  60                   RTS
00E733  1               
00E733  1               ; token $16 - "=" for numeric equality operator
00E733  1  20 4A E7     eq_op:  JSR     neq_op
00E736  1               
00E736  1               ; token $37 - "NOT"
00E736  1  20 15 E7     not_op: JSR     get16bit
00E739  1  98                   TYA
00E73A  1  20 08 E7             JSR     push_ya_noun_stk
00E73D  1  95 A0                STA     noun_stk_h_int,X
00E73F  1  C5 CE                CMP     acc
00E741  1  D0 06                BNE     Le749
00E743  1  C5 CF                CMP     acc+1
00E745  1  D0 02                BNE     Le749
00E747  1  F6 50                INC     noun_stk_l,X
00E749  1  60           Le749:  RTS
00E74A  1               
00E74A  1               ; token $17 - "#" for numeric inequality operator
00E74A  1               ; token $1B - "<>" for numeric inequality operator
00E74A  1  20 82 E7     neq_op: JSR     subtract
00E74D  1  20 59 E7             JSR     sgn_fn
00E750  1               
00E750  1               ; token $31 - "ABS"
00E750  1  20 15 E7     abs_fn: JSR     get16bit
00E753  1  24 CF                BIT     acc+1
00E755  1  30 1B                BMI     Se772
00E757  1  CA           Le757:  DEX
00E758  1  60           Le758:  RTS
00E759  1               
00E759  1               ; token $30 - "SGN"
00E759  1  20 15 E7     sgn_fn: JSR     get16bit
00E75C  1  A5 CF                LDA     acc+1
00E75E  1  D0 04                BNE     Le764
00E760  1  A5 CE                LDA     acc
00E762  1  F0 F3                BEQ     Le757
00E764  1  A9 FF        Le764:  LDA     #$FF
00E766  1  20 08 E7             JSR     push_ya_noun_stk
00E769  1  95 A0                STA     noun_stk_h_int,X
00E76B  1  24 CF                BIT     acc+1
00E76D  1  30 E9                BMI     Le758
00E76F  1               
00E76F  1               ; token $36 - "-" for unary negation
00E76F  1  20 15 E7     negate: JSR     get16bit
00E772  1               
00E772  1  98           Se772:  TYA
00E773  1  38                   SEC
00E774  1  E5 CE                SBC     acc
00E776  1  20 08 E7             JSR     push_ya_noun_stk
00E779  1  98                   TYA
00E77A  1  E5 CF                SBC     acc+1
00E77C  1  50 23                BVC     Le7a1
00E77E  1  A0 00        Le77e:  LDY     #$00
00E780  1  10 90                BPL     go_errmess_3
00E782  1               
00E782  1               ; token $13 - "-" for numeric subtraction
00E782  1  20 6F E7     subtract:       JSR     negate
00E785  1               
00E785  1               ; token $12 - "+" for numeric addition
00E785  1  20 15 E7     add:    JSR     get16bit
00E788  1  A5 CE                LDA     acc
00E78A  1  85 DA                STA     aux
00E78C  1  A5 CF                LDA     acc+1
00E78E  1  85 DB                STA     aux+1
00E790  1  20 15 E7             JSR     get16bit
00E793  1               
00E793  1  18           Se793:  CLC
00E794  1  A5 CE                LDA     acc
00E796  1  65 DA                ADC     aux
00E798  1  20 08 E7             JSR     push_ya_noun_stk
00E79B  1  A5 CF                LDA     acc+1
00E79D  1  65 DB                ADC     aux+1
00E79F  1  70 DD                BVS     Le77e
00E7A1  1  95 A0        Le7a1:  STA     noun_stk_h_int,X
00E7A3  1               
00E7A3  1               ; token $35 - "+" for unary positive
00E7A3  1  60           unary_pos:      RTS
00E7A4  1               
00E7A4  1               ; token $50 - "TAB" function
00E7A4  1  20 15 E7     tab_fn: JSR     get16bit
00E7A7  1  A4 CE                LDY     acc
00E7A9  1  F0 05                BEQ     Le7b0
00E7AB  1  88                   DEY
00E7AC  1  A5 CF                LDA     acc+1
00E7AE  1  F0 0C                BEQ     Le7bc
00E7B0  1  60           Le7b0:  RTS
00E7B1  1               
00E7B1  1               ; horizontal tab
00E7B1  1  A5 24        tabout: LDA     ch
00E7B3  1  09 07                ORA     #$07
00E7B5  1  A8                   TAY
00E7B6  1  C8                   INY
00E7B7  1  A9 A0        Le7b7:  LDA     #$A0
00E7B9  1  20 C9 E3             JSR     cout
00E7BC  1  C4 24        Le7bc:  CPY     ch
00E7BE  1  B0 F7                BCS     Le7b7
00E7C0  1  60                   RTS
00E7C1  1               
00E7C1  1               ; token $49 - "," in print, numeric follows
00E7C1  1  20 B1 E7     print_com_num:  JSR     tabout
00E7C4  1               
00E7C4  1               ; token $62 - "PRINT" numeric
00E7C4  1  20 15 E7     print_num:      JSR     get16bit
00E7C7  1  A5 CF                LDA     acc+1
00E7C9  1  10 0A                BPL     Le7d5
00E7CB  1  A9 AD                LDA     #$AD
00E7CD  1  20 C9 E3             JSR     cout
00E7D0  1  20 72 E7             JSR     Se772
00E7D3  1  50 EF                BVC     print_num
00E7D5  1  88           Le7d5:  DEY
00E7D6  1  84 D5                STY     cr_flag
00E7D8  1  86 CF                STX     acc+1
00E7DA  1  A6 CE                LDX     acc
00E7DC  1  20 1B E5             JSR     prdec
00E7DF  1  A6 CF                LDX     acc+1
00E7E1  1  60                   RTS
00E7E2  1               
00E7E2  1               ; token $0D - "AUTO" command
00E7E2  1  20 15 E7     auto_cmd:       JSR     get16bit
00E7E5  1  A5 CE                LDA     acc
00E7E7  1  85 F6                STA     auto_ln
00E7E9  1  A5 CF                LDA     acc+1
00E7EB  1  85 F7                STA     auto_ln+1
00E7ED  1  88                   DEY
00E7EE  1  84 F8                STY     auto_flag
00E7F0  1  C8                   INY
00E7F1  1  A9 0A                LDA     #$0A
00E7F3  1  85 F4        Le7f3:  STA     auto_inc
00E7F5  1  84 F5                STY     auto_inc+1
00E7F7  1  60                   RTS
00E7F8  1               
00E7F8  1               ; token $0E - "," in AUTO command
00E7F8  1  20 15 E7     auto_com:       JSR     get16bit
00E7FB  1  A5 CE                LDA     acc
00E7FD  1  A4 CF                LDY     acc+1
00E7FF  1  10 F2                BPL     Le7f3
00E801  1               
00E801  1               ; token $56 - "=" in FOR statement
00E801  1               ; token $71 - "=" in LET (or implied LET) statement
00E801  1  20 15 E7     var_assign:     JSR     get16bit
00E804  1  B5 50                LDA     noun_stk_l,X
00E806  1  85 DA                STA     aux
00E808  1  B5 78                LDA     noun_stk_h_str,X
00E80A  1  85 DB                STA     aux+1
00E80C  1  A5 CE                LDA     acc
00E80E  1  91 DA                STA     (aux),Y
00E810  1  C8                   INY
00E811  1  A5 CF                LDA     acc+1
00E813  1  91 DA                STA     (aux),Y
00E815  1  E8                   INX
00E816  1               
00E816  1  60           Te816:  RTS
00E817  1               
00E817  1               ; token $00 - begining of line
00E817  1               begin_line:
00E817  1  68                   PLA
00E818  1  68                   PLA
00E819  1               
00E819  1               ; token $03 - ":" statement separator
00E819  1  24 D5        colon:  BIT     cr_flag
00E81B  1  10 05                BPL     Le822
00E81D  1               
00E81D  1               ; token $63 - "PRINT" with no arg
00E81D  1  20 CD E3     print_cr:       JSR     crout
00E820  1               
00E820  1               ; token $47 - ";" at end of print statement
00E820  1  46 D5        print_semi:     LSR     cr_flag
00E822  1  60           Le822:  RTS
00E823  1               
00E823  1               
00E823  1               ; token $22 - "(" in string DIM
00E823  1               ; token $34 - "(" in numeric DIM
00E823  1               ; token $38 - "(" in numeric expression
00E823  1               ; token $3F - "(" in some PEEK, RND, SGN, ABS (PDL)
00E823  1  A0 FF        left_paren:     LDY     #$FF
00E825  1  84 D7                STY     precedence
00E827  1               
00E827  1               ; token $72 - ")" everywhere
00E827  1  60           right_paren:    RTS
00E828  1               
00E828  1               ; token $60 - "IF" statement
00E828  1  20 CD EF     if_stmt:        JSR     Sefcd
00E82B  1  F0 07                BEQ     Le834
00E82D  1  A9 25                LDA     #$25
00E82F  1  85 D6                STA     current_verb
00E831  1  88                   DEY
00E832  1  84 D4                STY     if_flag
00E834  1  E8           Le834:  INX
00E835  1  60                   RTS
00E836  1               ; RUN without CLR, used by Apple DOS
00E836  1  A5 CA        run_warm:       LDA     pp
00E838  1  A4 CB                LDY     pp+1
00E83A  1  D0 5A                BNE     Le896
00E83C  1               
00E83C  1               ; token $5C - "GOSUB" statement
00E83C  1  A0 41        gosub_stmt:     LDY     #$41
00E83E  1  A5 FC                LDA     gosub_nest_count
00E840  1  C9 08                CMP     #$08
00E842  1  B0 5E                BCS     go_errmess_4
00E844  1  A8                   TAY
00E845  1  E6 FC                INC     gosub_nest_count
00E847  1  A5 E0                LDA     pverb
00E849  1  99 00 01             STA     gstk_pverbl,Y
00E84C  1  A5 E1                LDA     pverb+1
00E84E  1  99 08 01             STA     gstk_pverbh,Y
00E851  1  A5 DC                LDA     pline
00E853  1  99 10 01             STA     gstk_plinel,Y
00E856  1  A5 DD                LDA     pline+1
00E858  1  99 18 01             STA     gstk_plineh,Y
00E85B  1               
00E85B  1               ; token $24 - "THEN"
00E85B  1               ; token $5F - "GOTO" statement
00E85B  1  20 15 E7     goto_stmt:      JSR     get16bit
00E85E  1  20 6D E5             JSR     find_line
00E861  1  90 04                BCC     Le867
00E863  1  A0 37                LDY     #$37
00E865  1  D0 3B                BNE     go_errmess_4
00E867  1  A5 E4        Le867:  LDA     p2
00E869  1  A4 E5                LDY     p2+1
00E86B  1               
00E86B  1               ; loop to run a program
00E86B  1  85 DC        run_loop:       STA     pline
00E86D  1  84 DD                STY     pline+1
00E86F  1  2C 11 D0             BIT     KBDCR
00E872  1  30 4F                BMI     Le8c3
00E874  1  18                   CLC
00E875  1  69 03                ADC     #$03
00E877  1  90 01                BCC     Le87a
00E879  1  C8                   INY
00E87A  1  A2 FF        Le87a:  LDX     #$FF
00E87C  1  86 D9                STX     run_flag
00E87E  1  9A                   TXS
00E87F  1  85 E0                STA     pverb
00E881  1  84 E1                STY     pverb+1
00E883  1  20 79 E6     Le883:  JSR     execute_stmt
00E886  1  24 D9                BIT     run_flag
00E888  1  10 49                BPL     end_stmt
00E88A  1  18                   CLC
00E88B  1  A0 00                LDY     #$00
00E88D  1  A5 DC                LDA     pline
00E88F  1  71 DC                ADC     (pline),Y
00E891  1  A4 DD                LDY     pline+1
00E893  1  90 01                BCC     Le896
00E895  1  C8                   INY
00E896  1  C5 4C        Le896:  CMP     himem
00E898  1  D0 D1                BNE     run_loop
00E89A  1  C4 4D                CPY     himem+1
00E89C  1  D0 CD                BNE     run_loop
00E89E  1  A0 34                LDY     #$34
00E8A0  1  46 D9                LSR     run_flag
00E8A2  1  4C E0 E3     go_errmess_4:   JMP     print_err_msg
00E8A5  1               
00E8A5  1               ; token $5B - "RETURN" statement
00E8A5  1  A0 4A        return_stmt:    LDY     #$4A
00E8A7  1  A5 FC                LDA     gosub_nest_count
00E8A9  1  F0 F7                BEQ     go_errmess_4
00E8AB  1  C6 FC                DEC     gosub_nest_count
00E8AD  1  A8                   TAY
00E8AE  1  B9 0F 01             LDA     gstk_plinel-1,Y
00E8B1  1  85 DC                STA     pline
00E8B3  1  B9 17 01             LDA     gstk_plineh-1,Y
00E8B6  1  85 DD                STA     pline+1
00E8B8  1  BE FF 00             LDX     a:synpag+1,Y            ; force absolute addressing mode
00E8BB  1  B9 07 01             LDA     gstk_pverbh-1,Y
00E8BE  1  A8           Le8be:  TAY
00E8BF  1  8A                   TXA
00E8C0  1  4C 7A E8             JMP     Le87a
00E8C3  1  A0 63        Le8c3:  LDY     #$63
00E8C5  1  20 C4 E3             JSR     Se3c4
00E8C8  1  A0 01                LDY     #$01
00E8CA  1  B1 DC                LDA     (pline),Y
00E8CC  1  AA                   TAX
00E8CD  1  C8                   INY
00E8CE  1  B1 DC                LDA     (pline),Y
00E8D0  1  20 1B E5             JSR     prdec
00E8D3  1               
00E8D3  1               ; token $51 - "END" statement
00E8D3  1  4C B3 E2     end_stmt:       JMP     warm
00E8D6  1  C6 FB        Le8d6:  DEC     for_nest_count
00E8D8  1               
00E8D8  1               ; token $59 - "NEXT" statement
00E8D8  1               ; token $5A - "," in NEXT statement
00E8D8  1  A0 5B        next_stmt:      LDY     #$5B
00E8DA  1  A5 FB                LDA     for_nest_count
00E8DC  1  F0 C4        Le8dc:  BEQ     go_errmess_4
00E8DE  1  A8                   TAY
00E8DF  1  B5 50                LDA     noun_stk_l,X
00E8E1  1  D9 1F 01             CMP     fstk_varl-1,Y
00E8E4  1  D0 F0                BNE     Le8d6
00E8E6  1  B5 78                LDA     noun_stk_h_str,X
00E8E8  1  D9 27 01             CMP     fstk_varh-1,Y
00E8EB  1  D0 E9                BNE     Le8d6
00E8ED  1  B9 2F 01             LDA     fstk_stepl-1,Y
00E8F0  1  85 DA                STA     aux
00E8F2  1  B9 37 01             LDA     fstk_steph-1,Y
00E8F5  1  85 DB                STA     aux+1
00E8F7  1  20 15 E7             JSR     get16bit
00E8FA  1  CA                   DEX
00E8FB  1  20 93 E7             JSR     Se793
00E8FE  1  20 01 E8             JSR     var_assign
00E901  1  CA                   DEX
00E902  1  A4 FB                LDY     for_nest_count
00E904  1  B9 67 01             LDA     fstk_toh-1,Y
00E907  1  95 9F                STA     syn_stk_l+31,X
00E909  1  B9 5F 01             LDA     fstk_tol-1,Y
00E90C  1  A0 00                LDY     #$00
00E90E  1  20 08 E7             JSR     push_ya_noun_stk
00E911  1  20 82 E7             JSR     subtract
00E914  1  20 59 E7             JSR     sgn_fn
00E917  1  20 15 E7             JSR     get16bit
00E91A  1  A4 FB                LDY     for_nest_count
00E91C  1  A5 CE                LDA     acc
00E91E  1  F0 05                BEQ     Le925
00E920  1  59 37 01             EOR     fstk_steph-1,Y
00E923  1  10 12                BPL     Le937
00E925  1  B9 3F 01     Le925:  LDA     fstk_plinel-1,Y
00E928  1  85 DC                STA     pline
00E92A  1  B9 47 01             LDA     fstk_plineh-1,Y
00E92D  1  85 DD                STA     pline+1
00E92F  1  BE 4F 01             LDX     fstk_pverbl-1,Y
00E932  1  B9 57 01             LDA     fstk_pverbh-1,Y
00E935  1  D0 87                BNE     Le8be
00E937  1  C6 FB        Le937:  DEC     for_nest_count
00E939  1  60                   RTS
00E93A  1               
00E93A  1               ; token $55 - "FOR" statement
00E93A  1  A0 54        for_stmt:       LDY     #$54
00E93C  1  A5 FB                LDA     for_nest_count
00E93E  1  C9 08                CMP     #$08
00E940  1  F0 9A                BEQ     Le8dc
00E942  1  E6 FB                INC     for_nest_count
00E944  1  A8                   TAY
00E945  1  B5 50                LDA     noun_stk_l,X
00E947  1  99 20 01             STA     fstk_varl,Y
00E94A  1  B5 78                LDA     noun_stk_h_str,X
00E94C  1  99 28 01             STA     fstk_varh,Y
00E94F  1  60                   RTS
00E950  1               
00E950  1               ; token $57 - "TO"
00E950  1  20 15 E7     to_clause:      JSR     get16bit
00E953  1  A4 FB                LDY     for_nest_count
00E955  1  A5 CE                LDA     acc
00E957  1  99 5F 01             STA     fstk_tol-1,Y
00E95A  1  A5 CF                LDA     acc+1
00E95C  1  99 67 01             STA     fstk_toh-1,Y
00E95F  1  A9 01                LDA     #$01
00E961  1  99 2F 01             STA     fstk_stepl-1,Y
00E964  1  A9 00                LDA     #$00
00E966  1  99 37 01     Le966:  STA     fstk_steph-1,Y
00E969  1  A5 DC                LDA     pline
00E96B  1  99 3F 01             STA     fstk_plinel-1,Y
00E96E  1  A5 DD                LDA     pline+1
00E970  1  99 47 01             STA     fstk_plineh-1,Y
00E973  1  A5 E0                LDA     pverb
00E975  1  99 4F 01             STA     fstk_pverbl-1,Y
00E978  1  A5 E1                LDA     pverb+1
00E97A  1  99 57 01             STA     fstk_pverbh-1,Y
00E97D  1  60                   RTS
00E97E  1               
00E97E  1  20 15 E7     Te97e:  JSR     get16bit
00E981  1  A4 FB                LDY     for_nest_count
00E983  1  A5 CE                LDA     acc
00E985  1  99 2F 01             STA     fstk_stepl-1,Y
00E988  1  A5 CF                LDA     acc+1
00E98A  1  4C 66 E9             JMP     Le966
00E98D  1  00 00 00 00          .byte   $00,$00,$00,$00,$00,$00,$00,$00 ; "........"
00E991  1  00 00 00 00  
00E995  1  00 00 00             .byte   $00,$00,$00                     ; "..."
00E998  1               
00E998  1               ; verb precedence
00E998  1               ; (verb_prec[token]&0xAA)>>1 for left (?)
00E998  1               ; verb_prec[token]&0x55 for right (?)
00E998  1               verb_prec_tbl:
00E998  1  00 00 00 AB          .byte   $00,$00,$00,$AB,$03,$03,$03,$03 ; "...+...."
00E99C  1  03 03 03 03  
00E9A0  1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$03,$03,$03 ; "........"
00E9A4  1  03 03 03 03  
00E9A8  1  03 03 3F 3F          .byte   $03,$03,$3F,$3F,$C0,$C0,$3C,$3C ; "..??@@<<"
00E9AC  1  C0 C0 3C 3C  
00E9B0  1  3C 3C 3C 3C          .byte   $3C,$3C,$3C,$3C,$3C,$30,$0F,$C0 ; "<<<<<0.@"
00E9B4  1  3C 30 0F C0  
00E9B8  1  CC FF 55 00          .byte   $CC,$FF,$55,$00,$AB,$AB,$03,$03 ; "L.U.++.."
00E9BC  1  AB AB 03 03  
00E9C0  1  FF FF 55 FF          .byte   $FF,$FF,$55,$FF,$FF,$55,$CF,$CF ; "..U..UOO"
00E9C4  1  FF 55 CF CF  
00E9C8  1  CF CF CF FF          .byte   $CF,$CF,$CF,$FF,$55,$C3,$C3,$C3 ; "OOO.UCCC"
00E9CC  1  55 C3 C3 C3  
00E9D0  1  55 F0 F0 CF          .byte   $55,$F0,$F0,$CF,$56,$56,$56,$55 ; "UppOVVVU"
00E9D4  1  56 56 56 55  
00E9D8  1  FF FF 55 03          .byte   $FF,$FF,$55,$03,$03,$03,$03,$03 ; "..U....."
00E9DC  1  03 03 03 03  
00E9E0  1  03 03 FF FF          .byte   $03,$03,$FF,$FF,$FF,$03,$03,$03 ; "........"
00E9E4  1  FF 03 03 03  
00E9E8  1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$03,$03,$03 ; "........"
00E9EC  1  03 03 03 03  
00E9F0  1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$00,$AB,$03 ; "......+."
00E9F4  1  03 00 AB 03  
00E9F8  1  57 03 03 03          .byte   $57,$03,$03,$03,$03,$07,$03,$03 ; "W......."
00E9FC  1  03 07 03 03  
00EA00  1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$03,$03,$03 ; "........"
00EA04  1  03 03 03 03  
00EA08  1  03 03 AA FF          .byte   $03,$03,$AA,$FF,$FF,$FF,$FF,$FF ; "..*....."
00EA0C  1  FF FF FF FF  
00EA10  1               verb_adr_l:
00EA10  1  17 FF FF 19          .byte   $17,$FF,$FF,$19,$5D,$35,$4B,$F2 ; "....]5Kr"
00EA14  1  5D 35 4B F2  
00EA18  1  EC 87 6F AD          .byte   $EC,$87,$6F,$AD,$B7,$E2,$F8,$54 ; "l.o-7bxT"
00EA1C  1  B7 E2 F8 54  
00EA20  1  80 96 85 82          .byte   $80,$96,$85,$82,$22,$10,$33,$4A ; "....".3J"
00EA24  1  22 10 33 4A  
00EA28  1  13 06 0B 4A          .byte   $13,$06,$0B,$4A,$01,$40,$47,$7A ; "...J.@Gz"
00EA2C  1  01 40 47 7A  
00EA30  1  00 FF 23 09          .byte   $00,$FF,$23,$09,$5B,$16,$B6,$CB ; "..#.[.6K"
00EA34  1  5B 16 B6 CB  
00EA38  1  FF FF FB FF          .byte   $FF,$FF,$FB,$FF,$FF,$24,$F6,$4E ; "..{..$vN"
00EA3C  1  FF 24 F6 4E  
00EA40  1  59 50 00 FF          .byte   $59,$50,$00,$FF,$23,$A3,$6F,$36 ; "YP..##o6"
00EA44  1  23 A3 6F 36  
00EA48  1  23 D7 1C 22          .byte   $23,$D7,$1C,$22,$C2,$AE,$BA,$23 ; "#W."B.:#"
00EA4C  1  C2 AE BA 23  
00EA50  1  FF FF 21 30          .byte   $FF,$FF,$21,$30,$1E,$03,$C4,$20 ; "..!0..D "
00EA54  1  1E 03 C4 20  
00EA58  1  00 C1 FF FF          .byte   $00,$C1,$FF,$FF,$FF,$A0,$30,$1E ; ".A... 0."
00EA5C  1  FF A0 30 1E  
00EA60  1  A4 D3 B6 BC          .byte   $A4,$D3,$B6,$BC,$AA,$3A,$01,$50 ; "$S6<*:.P"
00EA64  1  AA 3A 01 50  
00EA68  1  7E D8 D8 A5          .byte   $7E,$D8,$D8,$A5,$3C,$FF,$16,$5B ; "~XX%<..["
00EA6C  1  3C FF 16 5B  
00EA70  1  28 03 C4 1D          .byte   $28,$03,$C4,$1D,$00,$0C,$4E,$00 ; "(.D...N."
00EA74  1  00 0C 4E 00  
00EA78  1  3E 00 A6 B0          .byte   $3E,$00,$A6,$B0,$00,$BC,$C6,$57 ; ">.&0.<FW"
00EA7C  1  00 BC C6 57  
00EA80  1  8C 01 27 FF          .byte   $8C,$01,$27,$FF,$FF,$FF,$FF,$FF ; "..'....."
00EA84  1  FF FF FF FF  
00EA88  1               verb_adr_h:
00EA88  1  E8 FF FF E8          .byte   $E8,$FF,$FF,$E8,$E0,$E0,$E0,$EF ; "h..h```o"
00EA8C  1  E0 E0 E0 EF  
00EA90  1  EF E3 E3 E5          .byte   $EF,$E3,$E3,$E5,$E5,$E7,$E7,$EE ; "occeeggn"
00EA94  1  E5 E7 E7 EE  
00EA98  1  EF EF E7 E7          .byte   $EF,$EF,$E7,$E7,$E2,$EF,$E7,$E7 ; "ooggbogg"
00EA9C  1  E2 EF E7 E7  
00EAA0  1  EC EC EC E7          .byte   $EC,$EC,$EC,$E7,$EC,$EC,$EC,$E2 ; "lllglllb"
00EAA4  1  EC EC EC E2  
00EAA8  1  00 FF E8 E1          .byte   $00,$FF,$E8,$E1,$E8,$E8,$EF,$EB ; "..hahhok"
00EAAC  1  E8 E8 EF EB  
00EAB0  1  FF FF E0 FF          .byte   $FF,$FF,$E0,$FF,$FF,$EF,$EE,$EF ; "..`..ono"
00EAB4  1  FF EF EE EF  
00EAB8  1  E7 E7 00 FF          .byte   $E7,$E7,$00,$FF,$E8,$E7,$E7,$E7 ; "gg..hggg"
00EABC  1  E8 E7 E7 E7  
00EAC0  1  E8 E1 E2 EE          .byte   $E8,$E1,$E2,$EE,$EE,$EE,$EE,$E8 ; "habnnnnh"
00EAC4  1  EE EE EE E8  
00EAC8  1  FF FF E1 E1          .byte   $FF,$FF,$E1,$E1,$EF,$EE,$E7,$E8 ; "..aaongh"
00EACC  1  EF EE E7 E8  
00EAD0  1  EE E7 FF FF          .byte   $EE,$E7,$FF,$FF,$FF,$EE,$E1,$EF ; "ng...nao"
00EAD4  1  FF EE E1 EF  
00EAD8  1  E7 E8 EF EF          .byte   $E7,$E8,$EF,$EF,$EB,$E9,$E8,$E9 ; "ghookihi"
00EADC  1  EB E9 E8 E9  
00EAE0  1  E9 E8 E8 E8          .byte   $E9,$E8,$E8,$E8,$E8,$FF,$E8,$E8 ; "ihhhh.hh"
00EAE4  1  E8 FF E8 E8  
00EAE8  1  E8 EE E7 E8          .byte   $E8,$EE,$E7,$E8,$EF,$EF,$EE,$EF ; "hnghoono"
00EAEC  1  EF EF EE EF  
00EAF0  1  EE EF EE EE          .byte   $EE,$EF,$EE,$EE,$EF,$EE,$EE,$EE ; "nonnonnn"
00EAF4  1  EF EE EE EE  
00EAF8  1  E1 E8 E8 FF          .byte   $E1,$E8,$E8,$FF,$FF,$FF,$FF,$FF ; "ahh....."
00EAFC  1  FF FF FF FF  
00EB00  1               
00EB00  1               ; Error message strings. Last character has high bit unset.
00EB00  1               error_msg_tbl:
00EB00  1  BE B3 B2 B7          .byte   $BE,$B3,$B2,$B7,$B6,$37         ; ">32767"
00EB04  1  B6 37        
00EB06  1  D4 CF CF A0          .byte   $D4,$CF,$CF,$A0,$CC,$CF,$CE,$47 ; "TOO LONG"
00EB0A  1  CC CF CE 47  
00EB0E  1  D3 D9 CE D4          .byte   $D3,$D9,$CE,$D4,$C1,$58         ; "SYNTAX"
00EB12  1  C1 58        
00EB14  1  CD C5 CD A0          .byte   $CD,$C5,$CD,$A0,$C6,$D5,$CC,$4C ; "MEM FULL"
00EB18  1  C6 D5 CC 4C  
00EB1C  1  D4 CF CF A0          .byte   $D4,$CF,$CF,$A0,$CD,$C1,$CE,$D9,$A0,$D0,$C1,$D2,$C5,$CE,$53 ; "TOO MANY PARENS"
00EB20  1  CD C1 CE D9  
00EB24  1  A0 D0 C1 D2  
00EB2B  1  D3 D4 D2 C9          .byte   $D3,$D4,$D2,$C9,$CE,$47         ; "STRING"
00EB2F  1  CE 47        
00EB31  1  CE CF A0 C5          .byte   $CE,$CF,$A0,$C5,$CE,$44         ; "NO END"
00EB35  1  CE 44        
00EB37  1  C2 C1 C4 A0          .byte   $C2,$C1,$C4,$A0,$C2,$D2,$C1,$CE,$C3,$48 ; "BAD BRANCH"
00EB3B  1  C2 D2 C1 CE  
00EB3F  1  C3 48        
00EB41  1  BE B8 A0 C7          .byte   $BE,$B8,$A0,$C7,$CF,$D3,$D5,$C2,$53     ; ">8 GOSUBS"
00EB45  1  CF D3 D5 C2  
00EB49  1  53           
00EB4A  1  C2 C1 C4 A0          .byte   $C2,$C1,$C4,$A0,$D2,$C5,$D4,$D5,$D2,$4E ; "BAD RETURN"
00EB4E  1  D2 C5 D4 D5  
00EB52  1  D2 4E        
00EB54  1  BE B8 A0 C6          .byte   $BE,$B8,$A0,$C6,$CF,$D2,$53     ; ">8 FORS"
00EB58  1  CF D2 53     
00EB5B  1  C2 C1 C4 A0          .byte   $C2,$C1,$C4,$A0,$CE,$C5,$D8,$54 ; "BAD NEXT"
00EB5F  1  CE C5 D8 54  
00EB63  1  D3 D4 CF D0          .byte   $D3,$D4,$CF,$D0,$D0,$C5,$C4,$A0,$C1,$D4,$20 ; "STOPPED AT "
00EB67  1  D0 C5 C4 A0  
00EB6B  1  C1 D4 20     
00EB6E  1  AA AA AA 20          .byte   $AA,$AA,$AA,$20                 ; "*** "
00EB72  1  A0 C5 D2 D2          .byte   $A0,$C5,$D2,$D2,$0D             ; " ERR.\n"
00EB76  1  0D           
00EB77  1  BE B2 B5 35          .byte   $BE,$B2,$B5,$35                 ; ">255"
00EB7B  1  D2 C1 CE C7          .byte   $D2,$C1,$CE,$C7,$45             ; RANGE"
00EB7F  1  45           
00EB80  1  C4 C9 4D             .byte   $C4,$C9,$4D                     ; "DIM"
00EB83  1  D3 D4 D2 A0          .byte   $D3,$D4,$D2,$A0,$CF,$D6,$C6,$4C ; "STR OVFL"
00EB87  1  CF D6 C6 4C  
00EB8B  1  DC 0D                .byte   $DC,$0D                         ; "\\\n"
00EB8D  1  D2 C5 D4 D9          .byte   $D2,$C5,$D4,$D9,$D0,$C5,$A0,$CC,$C9,$CE,$C5,$8D ; "RETYPE LINE\n"
00EB91  1  D0 C5 A0 CC  
00EB95  1  C9 CE C5 8D  
00EB99  1  3F                   .byte   $3F                             ; "?"
00EB9A  1  46 D9        Leb9a:  LSR     run_flag
00EB9C  1  90 03                BCC     Leba1
00EB9E  1  4C C3 E8             JMP     Le8c3
00EBA1  1  A6 CF        Leba1:  LDX     acc+1
00EBA3  1  9A                   TXS
00EBA4  1  A6 CE                LDX     acc
00EBA6  1  A0 8D                LDY     #$8D
00EBA8  1  D0 02                BNE     Lebac
00EBAA  1               
00EBAA  1               ; token $54 - "INPUT" statement, numeric, no prompt
00EBAA  1  A0 99        input_num_stmt: LDY     #$99
00EBAC  1  20 C4 E3     Lebac:  JSR     Se3c4
00EBAF  1  86 CE                STX     acc
00EBB1  1  BA                   TSX
00EBB2  1  86 CF                STX     acc+1
00EBB4  1  A0 FE                LDY     #$FE
00EBB6  1  84 D9                STY     run_flag
00EBB8  1  C8                   INY
00EBB9  1  84 C8                STY     text_index
00EBBB  1  20 99 E2             JSR     Se299
00EBBE  1  84 F1                STY     token_index
00EBC0  1  A2 20                LDX     #$20
00EBC2  1  A9 30                LDA     #$30
00EBC4  1  20 91 E4             JSR     Se491
00EBC7  1  E6 D9                INC     run_flag
00EBC9  1  A6 CE                LDX     acc
00EBCB  1               
00EBCB  1               ; token $27 - "," numeric input
00EBCB  1  A4 C8        input_num_comma:        LDY     text_index
00EBCD  1  0A                   ASL
00EBCE  1  85 CE        Lebce:  STA     acc
00EBD0  1  C8                   INY
00EBD1  1  B9 00 02             LDA     buffer,Y
00EBD4  1  C9 74                CMP     #$74
00EBD6  1  F0 D2                BEQ     input_num_stmt
00EBD8  1  49 B0                EOR     #$B0
00EBDA  1  C9 0A                CMP     #$0A
00EBDC  1  B0 F0                BCS     Lebce
00EBDE  1  C8                   INY
00EBDF  1  C8                   INY
00EBE0  1  84 C8                STY     text_index
00EBE2  1  B9 00 02             LDA     buffer,Y
00EBE5  1  48                   PHA
00EBE6  1  B9 FF 01             LDA     buffer-1,Y
00EBE9  1  A0 00                LDY     #$00
00EBEB  1  20 08 E7             JSR     push_ya_noun_stk
00EBEE  1  68                   PLA
00EBEF  1  95 A0                STA     noun_stk_h_int,X
00EBF1  1  A5 CE                LDA     acc
00EBF3  1  C9 C7                CMP     #$C7
00EBF5  1  D0 03                BNE     Lebfa
00EBF7  1  20 6F E7             JSR     negate
00EBFA  1  4C 01 E8     Lebfa:  JMP     var_assign
00EBFD  1               
00EBFD  1  FF FF FF 50          .byte   $FF,$FF,$FF,$50
00EC01  1               
00EC01  1  20 13 EC     Tec01:  JSR     Tec13
00EC04  1  D0 15                BNE     Lec1b
00EC06  1               
00EC06  1  20 0B EC     Tec06:  JSR     Tec0b
00EC09  1  D0 10                BNE     Lec1b
00EC0B  1               
00EC0B  1  20 82 E7     Tec0b:  JSR     subtract
00EC0E  1  20 6F E7             JSR     negate
00EC11  1  50 03                BVC     Lec16
00EC13  1               
00EC13  1  20 82 E7     Tec13:  JSR     subtract
00EC16  1  20 59 E7     Lec16:  JSR     sgn_fn
00EC19  1  56 50                LSR     noun_stk_l,X
00EC1B  1  4C 36 E7     Lec1b:  JMP     not_op
00EC1E  1               
00EC1E  1  FF FF                .byte   $FF,$FF
00EC20  1               
00EC20  1               ; indexes into syntabl
00EC20  1               syntabl_index:
00EC20  1  C1 FF 7F D1          .byte   $C1,$FF,$7F,$D1,$CC,$C7,$CF,$CE ; "A..QLGON"
00EC24  1  CC C7 CF CE  
00EC28  1  C5 9A 98 8B          .byte   $C5,$9A,$98,$8B,$96,$95,$93,$BF ; "E......?"
00EC2C  1  96 95 93 BF  
00EC30  1  B2 32 2D 2B          .byte   $B2,$32,$2D,$2B,$BC,$B0,$AC,$BE ; "22-+<0,>"
00EC34  1  BC B0 AC BE  
00EC38  1  35 8E 61 FF          .byte   $35,$8E,$61,$FF,$FF,$FF,$DD,$FB ; "5.a...]{"
00EC3C  1  FF FF DD FB  
00EC40  1               
00EC40  1  20 C9 EF     Tec40:  JSR     Sefc9
00EC43  1  15 4F                ORA     rnd+1,X
00EC45  1  10 05                BPL     Lec4c
00EC47  1               
00EC47  1  20 C9 EF     Tec47:  JSR     Sefc9
00EC4A  1  35 4F                AND     rnd+1,X
00EC4C  1  95 50        Lec4c:  STA     noun_stk_l,X
00EC4E  1  10 CB                BPL     Lec1b
00EC50  1  4C C9 EF             JMP     Sefc9
00EC53  1  40 60 8D 60          .byte   $40,$60,$8D,$60,$8B,$00,$7E,$8C ; "@`.`..~."
00EC57  1  8B 00 7E 8C  
00EC5B  1  33 00 00 60          .byte   $33,$00,$00,$60,$03,$BF,$12,$00 ; "3..`.?.."
00EC5F  1  03 BF 12 00  
00EC63  1  40 89 C9 47          .byte   $40,$89,$C9,$47,$9D,$17,$68,$9D ; "@.IG..h."
00EC67  1  9D 17 68 9D  
00EC6B  1  0A 00 40 60          .byte   $0A,$00,$40,$60,$8D,$60,$8B,$00 ; "..@`.`.."
00EC6F  1  8D 60 8B 00  
00EC73  1  7E 8C 3C 00          .byte   $7E,$8C,$3C,$00,$00,$60,$03,$BF ; "~.<..`.?"
00EC77  1  00 60 03 BF  
00EC7B  1  1B 4B 67 B4          .byte   $1B,$4B,$67,$B4,$A1,$07,$8C,$07 ; ".Kg4!..."
00EC7F  1  A1 07 8C 07  
00EC83  1  AE A9 AC A8          .byte   $AE,$A9,$AC,$A8,$67,$8C,$07,$B4 ; ".),(g..4"
00EC87  1  67 8C 07 B4  
00EC8B  1  AF AC B0 67          .byte   $AF,$AC,$B0,$67,$9D,$B2,$AF,$AC ; "/,0g.2/,"
00EC8F  1  9D B2 AF AC  
00EC93  1  AF A3 67 8C          .byte   $AF,$A3,$67,$8C,$07,$A5,$AB,$AF ; "/#g..%+/"
00EC97  1  07 A5 AB AF  
00EC9B  1  B0 F4 AE A9          .byte   $B0,$F4,$AE,$A9,$B2,$B0,$7F,$0E ; "0t.)20.."
00EC9F  1  B2 B0 7F 0E  
00ECA3  1  27 B4 AE A9          .byte   $27,$B4,$AE,$A9,$B2,$B0,$7F,$0E ; "'4.)20.."
00ECA7  1  B2 B0 7F 0E  
00ECAB  1  28 B4 AE A9          .byte   $28,$B4,$AE,$A9,$B2,$B0,$64,$07 ; "(4.)20d."
00ECAF  1  B2 B0 64 07  
00ECB3  1  A6 A9 67 AF          .byte   $A6,$A9,$67,$AF,$B4,$AF,$A7,$78 ; "&)g/4/'x"
00ECB7  1  B4 AF A7 78  
00ECBB  1  B4 A5 AC 78          .byte   $B4,$A5,$AC,$78,$7F,$02,$AD,$A5 ; "4%,x..-%"
00ECBF  1  7F 02 AD A5  
00ECC3  1  B2 67 A2 B5          .byte   $B2,$67,$A2,$B5,$B3,$AF,$A7,$EE ; "2g"53/'n"
00ECC7  1  B3 AF A7 EE  
00ECCB  1  B2 B5 B4 A5          .byte   $B2,$B5,$B4,$A5,$B2,$7E,$8C,$39 ; "254%2~.9"
00ECCF  1  B2 7E 8C 39  
00ECD3  1  B4 B8 A5 AE          .byte   $B4,$B8,$A5,$AE,$67,$B0,$A5,$B4 ; "48%.g0%4"
00ECD7  1  67 B0 A5 B4  
00ECDB  1  B3 27 AF B4          .byte   $B3,$27,$AF,$B4,$07,$9D,$19,$B2 ; "3'/4...2"
00ECDF  1  07 9D 19 B2  
00ECE3  1  AF A6 7F 05          .byte   $AF,$A6,$7F,$05,$37,$B4,$B5,$B0 ; "/&..7450"
00ECE7  1  37 B4 B5 B0  
00ECEB  1  AE A9 7F 05          .byte   $AE,$A9,$7F,$05,$28,$B4,$B5,$B0 ; ".)..(450"
00ECEF  1  28 B4 B5 B0  
00ECF3  1  AE A9 7F 05          .byte   $AE,$A9,$7F,$05,$2A,$B4,$B5,$B0 ; ".)..*450"
00ECF7  1  2A B4 B5 B0  
00ECFB  1  AE A9 E4 AE          .byte   $AE,$A9,$E4,$AE,$A5,$00,$FF,$FF ; ".)d.%..."
00ECFF  1  A5 00 FF FF  
00ED03  1               syntabl2:
00ED03  1  47 A2 A1 B4          .byte   $47,$A2,$A1,$B4,$7F,$0D,$30,$AD ; "G"!4..0-"
00ED07  1  7F 0D 30 AD  
00ED0B  1  A9 A4 7F 0D          .byte   $A9,$A4,$7F,$0D,$23,$AD,$A9,$A4 ; ")$..#-)$"
00ED0F  1  23 AD A9 A4  
00ED13  1  67 AC AC A1          .byte   $67,$AC,$AC,$A1,$A3,$00,$40,$80 ; "g,,!#.@."
00ED17  1  A3 00 40 80  
00ED1B  1  C0 C1 80 00          .byte   $C0,$C1,$80,$00,$47,$8C,$68,$8C ; "@A..G.h."
00ED1F  1  47 8C 68 8C  
00ED23  1  DB 67 9B 68          .byte   $DB,$67,$9B,$68,$9B,$50,$8C,$63 ; "[g.h.P.c"
00ED27  1  9B 50 8C 63  
00ED2B  1  8C 7F 01 51          .byte   $8C,$7F,$01,$51,$07,$88,$29,$84 ; "...Q..)."
00ED2F  1  07 88 29 84  
00ED33  1  80 C4 80 57          .byte   $80,$C4,$80,$57,$71,$07,$88,$14 ; ".D.Wq..."
00ED37  1  71 07 88 14  
00ED3B  1  ED A5 AD AF          .byte   $ED,$A5,$AD,$AF,$AC,$ED,$A5,$AD ; "m%-/,m%-"
00ED3F  1  AC ED A5 AD  
00ED43  1  A9 A8 F2 AF          .byte   $A9,$A8,$F2,$AF,$AC,$AF,$A3,$71 ; ")(r/,/#q"
00ED47  1  AC AF A3 71  
00ED4B  1  08 88 AE A5          .byte   $08,$88,$AE,$A5,$AC,$68,$83,$08 ; "...%,h.."
00ED4F  1  AC 68 83 08  
00ED53  1  68 9D 08 71          .byte   $68,$9D,$08,$71,$07,$88,$60,$76 ; "h..q..`v"
00ED57  1  07 88 60 76  
00ED5B  1  B4 AF AE 76          .byte   $B4,$AF,$AE,$76,$8D,$76,$8B,$51 ; "4/.v.v.Q"
00ED5F  1  8D 76 8B 51  
00ED63  1  07 88 19 B8          .byte   $07,$88,$19,$B8,$A4,$AE,$B2,$F2 ; "...8$.2r"
00ED67  1  A4 AE B2 F2  
00ED6B  1  B3 B5 F3 A2          .byte   $B3,$B5,$F3,$A2,$A1,$EE,$A7,$B3 ; "35s"!n'3"
00ED6F  1  A1 EE A7 B3  
00ED73  1  E4 AE B2 EB          .byte   $E4,$AE,$B2,$EB,$A5,$A5,$B0,$51 ; "d.2k%%0Q"
00ED77  1  A5 A5 B0 51  
00ED7B  1  07 88 39 81          .byte   $07,$88,$39,$81,$C1,$4F,$7F,$0F ; "..9.AO.."
00ED7F  1  C1 4F 7F 0F  
00ED83  1  2F 00 51 06          .byte   $2F,$00,$51,$06,$88,$29,$C2,$0C ; "/.Q..)B."
00ED87  1  88 29 C2 0C  
00ED8B  1  82 57 8C 6A          .byte   $82,$57,$8C,$6A,$8C,$42,$AE,$A5 ; ".W.j.B.%"
00ED8F  1  8C 42 AE A5  
00ED93  1  A8 B4 60 AE          .byte   $A8,$B4,$60,$AE,$A5,$A8,$B4,$4F ; "(4`.%(4O"
00ED97  1  A5 A8 B4 4F  
00ED9B  1  7E 1E 35 8C          .byte   $7E,$1E,$35,$8C,$27,$51,$07,$88 ; "~.5.'Q.."
00ED9F  1  27 51 07 88  
00EDA3  1  09 8B FE E4          .byte   $09,$8B,$FE,$E4,$AF,$AD,$F2,$AF ; "..~d/-r/"
00EDA7  1  AF AD F2 AF  
00EDAB  1  E4 AE A1 DC          .byte   $E4,$AE,$A1,$DC,$DE,$9C,$DD,$9C ; "d.!\^.]."
00EDAF  1  DE 9C DD 9C  
00EDB3  1  DE DD 9E C3          .byte   $DE,$DD,$9E,$C3,$DD,$CF,$CA,$CD ; "^].C]OJM"
00EDB7  1  DD CF CA CD  
00EDBB  1  CB 00 47 9D          .byte   $CB,$00,$47,$9D,$AD,$A5,$AD,$AF ; "K.G.-%-/"
00EDBF  1  AD A5 AD AF  
00EDC3  1  AC 76 9D AD          .byte   $AC,$76,$9D,$AD,$A5,$AD,$A9,$A8 ; ",v.-%-)("
00EDC7  1  A5 AD A9 A8  
00EDCB  1  E6 A6 AF 60          .byte   $E6,$A6,$AF,$60,$8C,$20,$AF,$B4 ; "f&/`. /4"
00EDCF  1  8C 20 AF B4  
00EDD3  1  B5 A1 F2 AC          .byte   $B5,$A1,$F2,$AC,$A3,$F2,$A3,$B3 ; "5!r,#r#3"
00EDD7  1  A3 F2 A3 B3  
00EDDB  1  60 8C 20 AC          .byte   $60,$8C,$20,$AC,$A5,$A4,$EE,$B5 ; "`. ,%$n5"
00EDDF  1  A5 A4 EE B5  
00EDE3  1  B2 60 AE B5          .byte   $B2,$60,$AE,$B5,$B2,$F4,$B3,$A9 ; "2`.52t3)"
00EDE7  1  B2 F4 B3 A9  
00EDEB  1  AC 60 8C 20          .byte   $AC,$60,$8C,$20,$B4,$B3,$A9,$AC ; ",`. 43),"
00EDEF  1  B4 B3 A9 AC  
00EDF3  1  7A 7E 9A 22          .byte   $7A,$7E,$9A,$22,$20,$00,$60,$03 ; "z~." .`."
00EDF7  1  20 00 60 03  
00EDFB  1  BF 60 03 BF          .byte   $BF,$60,$03,$BF,$1F             ; "?`.?."
00EDFF  1  1F           
00EE00  1               
00EE00  1               ; token $48 - "," string output
00EE00  1  20 B1 E7     print_str_comma:        JSR     tabout
00EE03  1               
00EE03  1               ; token $45 - ";" string output
00EE03  1               ; token $61 - "PRINT" string
00EE03  1  E8           print_str:      INX
00EE04  1  E8                   INX
00EE05  1  B5 4F                LDA     rnd+1,X
00EE07  1  85 DA                STA     aux
00EE09  1  B5 77                LDA     syn_stk_h+31,X
00EE0B  1  85 DB                STA     aux+1
00EE0D  1  B4 4E                LDY     rnd,X
00EE0F  1  98           Lee0f:  TYA
00EE10  1  D5 76                CMP     syn_stk_h+30,X
00EE12  1  B0 09                BCS     Lee1d
00EE14  1  B1 DA                LDA     (aux),Y
00EE16  1  20 C9 E3             JSR     cout
00EE19  1  C8                   INY
00EE1A  1  4C 0F EE             JMP     Lee0f
00EE1D  1  A9 FF        Lee1d:  LDA     #$FF
00EE1F  1  85 D5                STA     cr_flag
00EE21  1  60                   RTS
00EE22  1               
00EE22  1               ; token $3B - "LEN(" function
00EE22  1  E8           len_fn: INX
00EE23  1  A9 00                LDA     #$00
00EE25  1  95 78                STA     noun_stk_h_str,X
00EE27  1  95 A0                STA     noun_stk_h_int,X
00EE29  1  B5 77                LDA     syn_stk_h+31,X
00EE2B  1  38                   SEC
00EE2C  1  F5 4F                SBC     rnd+1,X
00EE2E  1  95 50                STA     noun_stk_l,X
00EE30  1  4C 23 E8             JMP     left_paren
00EE33  1               
00EE33  1  FF                   .byte   $FF
00EE34  1               
00EE34  1  20 15 E7     getbyte:        JSR     get16bit
00EE37  1  A5 CF                LDA     acc+1
00EE39  1  D0 28                BNE     gr_255_err
00EE3B  1  A5 CE                LDA     acc
00EE3D  1  60                   RTS
00EE3E  1               
00EE3E  1               ; token $68 - "," for PLOT statement (???)
00EE3E  1  20 34 EE     plot_comma:     JSR     getbyte
00EE41  1  A4 C8                LDY     text_index
00EE43  1  C9 30                CMP     #$30
00EE45  1  B0 21                BCS     range_err
00EE47  1  C0 28                CPY     #$28
00EE49  1  B0 1D                BCS     range_err
00EE4B  1  60                   RTS
00EE4C  1  EA                   NOP
00EE4D  1  EA                   NOP
00EE4E  1               
00EE4E  1  20 34 EE     Tee4e:  JSR     getbyte
00EE51  1  60                   RTS
00EE52  1  EA                   NOP
00EE53  1  8A           Tee5e:  TXA
00EE54  1  A2 01                LDX     #$01
00EE56  1  B4 CE        l123:   LDY     acc,X
00EE58  1  94 4C                STY     himem,X
00EE5A  1  B4 48                LDY     var,X
00EE5C  1  94 CA                STY     pp,X
00EE5E  1  CA                   DEX
00EE5F  1  F0 F5                BEQ     l123
00EE61  1  AA                   TAX
00EE62  1  60                   RTS
00EE63  1  A0 77        gr_255_err:     LDY     #$77            ; > 255 error
00EE65  1  4C E0 E3     go_errmess_5:   JMP     print_err_msg
00EE68  1  A0 7B        range_err:      LDY     #$7B            ; range error
00EE6A  1  D0 F9                BNE     go_errmess_5
00EE6C  1               
00EE6C  1  20 54 E2     See6c:  JSR     Se254
00EE6F  1  A5 DA                LDA     aux
00EE71  1  D0 07                BNE     Lee7a
00EE73  1  A5 DB                LDA     aux+1
00EE75  1  D0 03                BNE     Lee7a
00EE77  1  4C 7E E7             JMP     Le77e
00EE7A  1  06 CE        Lee7a:  ASL     acc
00EE7C  1  26 CF                ROL     acc+1
00EE7E  1  26 E6                ROL     p3
00EE80  1  26 E7                ROL     p3+1
00EE82  1  A5 E6                LDA     p3
00EE84  1  C5 DA                CMP     aux
00EE86  1  A5 E7                LDA     p3+1
00EE88  1  E5 DB                SBC     aux+1
00EE8A  1  90 0A                BCC     Lee96
00EE8C  1  85 E7                STA     p3+1
00EE8E  1  A5 E6                LDA     p3
00EE90  1  E5 DA                SBC     aux
00EE92  1  85 E6                STA     p3
00EE94  1  E6 CE                INC     acc
00EE96  1  88           Lee96:  DEY
00EE97  1  D0 E1                BNE     Lee7a
00EE99  1  60                   RTS
00EE9A  1               
00EE9A  1  FF FF FF FF          .byte   $FF,$FF,$FF,$FF,$FF,$FF
00EE9E  1  FF FF        
00EEA0  1               
00EEA0  1               ; token $4D - "CALL" statement
00EEA0  1  20 15 E7     call_stmt:      JSR     get16bit
00EEA3  1  6C CE 00             JMP     (acc)
00EEA6  1  A5 4C        l1233:  LDA     himem
00EEA8  1  D0 02                BNE     l1235
00EEAA  1  C6 4D                DEC     himem+1
00EEAC  1  C6 4C        l1235:  DEC     himem
00EEAE  1  A5 48                LDA     var
00EEB0  1  D0 02                BNE     l1236
00EEB2  1  C6 49                DEC     var+1
00EEB4  1  C6 48        l1236:  DEC     var
00EEB6  1  A0 00        l1237:  LDY     #$00
00EEB8  1  B1 4C                LDA     (himem),Y
00EEBA  1  91 48                STA     (var),Y
00EEBC  1  A5 CA                LDA     pp
00EEBE  1  C5 4C                CMP     himem
00EEC0  1  A5 CB                LDA     pp+1
00EEC2  1  E5 4D                SBC     himem+1
00EEC4  1  90 E0                BCC     l1233
00EEC6  1  4C 53 EE             JMP     Tee5e
00EEC9  1  C9 28                CMP     #$28
00EECB  1  B0 9B        Leecb:  BCS     range_err
00EECD  1  A8                   TAY
00EECE  1  A5 C8                LDA     text_index
00EED0  1  60                   RTS
00EED1  1  EA                   NOP
00EED2  1  EA                   NOP
00EED3  1               
00EED3  1               print_err_msg1:
00EED3  1  98                   TYA
00EED4  1  AA                   TAX
00EED5  1  A0 6E                LDY     #$6E
00EED7  1  20 C4 E3             JSR     Se3c4
00EEDA  1  8A                   TXA
00EEDB  1  A8                   TAY
00EEDC  1  20 C4 E3             JSR     Se3c4
00EEDF  1  A0 72                LDY     #$72
00EEE1  1  4C C4 E3             JMP     Se3c4
00EEE4  1               
00EEE4  1  20 15 E7     Seee4:  JSR     get16bit
00EEE7  1  06 CE        Leee7:  ASL     acc
00EEE9  1  26 CF                ROL     acc+1
00EEEB  1  30 FA                BMI     Leee7
00EEED  1  B0 DC                BCS     Leecb
00EEEF  1  D0 04                BNE     Leef5
00EEF1  1  C5 CE                CMP     acc
00EEF3  1  B0 D6                BCS     Leecb
00EEF5  1  60           Leef5:  RTS
00EEF6  1               
00EEF6  1               ; token $2E - "PEEK" fn (uses $3F left paren)
00EEF6  1  20 15 E7     peek_fn:        JSR     get16bit
00EEF9  1  B1 CE                LDA     (acc),Y
00EEFB  1  94 9F                STY     syn_stk_l+31,X
00EEFD  1  4C 08 E7             JMP     push_ya_noun_stk
00EF00  1               
00EF00  1               ; token $65 - "," for POKE statement
00EF00  1  20 34 EE     poke_stmt:      JSR     getbyte
00EF03  1  A5 CE                LDA     acc
00EF05  1  48                   PHA
00EF06  1  20 15 E7             JSR     get16bit
00EF09  1  68                   PLA
00EF0A  1  91 CE                STA     (acc),Y
00EF0C  1               
00EF0C  1  60           Tef0c:  RTS
00EF0D  1               
00EF0D  1  FF FF FF             .byte   $FF,$FF,$FF
00EF10  1               
00EF10  1               ; token $15 - "/" for numeric division
00EF10  1  20 6C EE     divide: JSR     See6c
00EF13  1  A5 CE                LDA     acc
00EF15  1  85 E6                STA     p3
00EF17  1  A5 CF                LDA     acc+1
00EF19  1  85 E7                STA     p3+1
00EF1B  1  4C 44 E2             JMP     Le244
00EF1E  1               
00EF1E  1               ; token $44 - "," next var in DIM statement is numeric
00EF1E  1               ; token $4F - "DIM", next var is numeric
00EF1E  1  20 E4 EE     dim_num:        JSR     Seee4
00EF21  1  4C 34 E1             JMP     Le134
00EF24  1               
00EF24  1               ; token $2D - "(" for numeric array subscript
00EF24  1  20 E4 EE     num_array_subs: JSR     Seee4
00EF27  1  B4 78                LDY     noun_stk_h_str,X
00EF29  1  B5 50                LDA     noun_stk_l,X
00EF2B  1  69 FE                ADC     #$FE
00EF2D  1  B0 01                BCS     Lef30
00EF2F  1  88                   DEY
00EF30  1  85 DA        Lef30:  STA     aux
00EF32  1  84 DB                STY     aux+1
00EF34  1  18                   CLC
00EF35  1  65 CE                ADC     acc
00EF37  1  95 50                STA     noun_stk_l,X
00EF39  1  98                   TYA
00EF3A  1  65 CF                ADC     acc+1
00EF3C  1  95 78                STA     noun_stk_h_str,X
00EF3E  1  A0 00                LDY     #$00
00EF40  1  B5 50                LDA     noun_stk_l,X
00EF42  1  D1 DA                CMP     (aux),Y
00EF44  1  C8                   INY
00EF45  1  B5 78                LDA     noun_stk_h_str,X
00EF47  1  F1 DA                SBC     (aux),Y
00EF49  1  B0 80                BCS     Leecb
00EF4B  1  4C 23 E8             JMP     left_paren
00EF4E  1               
00EF4E  1               ; token $2F - "RND" fn (uses $3F left paren)
00EF4E  1  20 15 E7     rnd_fn: JSR     get16bit
00EF51  1  A5 4E                LDA     rnd
00EF53  1  20 08 E7             JSR     push_ya_noun_stk
00EF56  1  A5 4F                LDA     rnd+1
00EF58  1  D0 04                BNE     Lef5e
00EF5A  1  C5 4E                CMP     rnd
00EF5C  1  69 00                ADC     #$00
00EF5E  1  29 7F        Lef5e:  AND     #$7F
00EF60  1  85 4F                STA     rnd+1
00EF62  1  95 A0                STA     noun_stk_h_int,X
00EF64  1  A0 11                LDY     #$11
00EF66  1  A5 4F        Lef66:  LDA     rnd+1
00EF68  1  0A                   ASL
00EF69  1  18                   CLC
00EF6A  1  69 40                ADC     #$40
00EF6C  1  0A                   ASL
00EF6D  1  26 4E                ROL     rnd
00EF6F  1  26 4F                ROL     rnd+1
00EF71  1  88                   DEY
00EF72  1  D0 F2                BNE     Lef66
00EF74  1  A5 CE                LDA     acc
00EF76  1  20 08 E7             JSR     push_ya_noun_stk
00EF79  1  A5 CF                LDA     acc+1
00EF7B  1  95 A0                STA     noun_stk_h_int,X
00EF7D  1  4C 7A E2             JMP     mod_op
00EF80  1               
00EF80  1  20 15 E7     Tef80:  JSR     get16bit
00EF83  1  A4 CE                LDY     acc
00EF85  1  C4 4C                CPY     himem
00EF87  1  A5 CF                LDA     acc+1
00EF89  1  E5 4D                SBC     himem+1
00EF8B  1  90 1F                BCC     Lefab
00EF8D  1  84 48                STY     var
00EF8F  1  A5 CF                LDA     acc+1
00EF91  1  85 49                STA     var+1
00EF93  1  4C B6 EE     Lef93:  JMP     l1237
00EF96  1               
00EF96  1  20 15 E7     Tef96:  JSR     get16bit
00EF99  1  A4 CE                LDY     acc
00EF9B  1  C4 CA                CPY     pp
00EF9D  1  A5 CF                LDA     acc+1
00EF9F  1  E5 CB                SBC     pp+1
00EFA1  1  B0 09                BCS     Lefab
00EFA3  1  84 4A                STY     lomem
00EFA5  1  A5 CF                LDA     acc+1
00EFA7  1  85 4B                STA     lomem+1
00EFA9  1  4C B7 E5             JMP     clr
00EFAC  1  4C CB EE     Lefab:  JMP     Leecb
00EFAF  1  EA                   NOP
00EFB0  1  EA                   NOP
00EFB1  1  EA                   NOP
00EFB2  1  EA                   NOP
00EFB3  1  20 C9 EF     Lefb3:  JSR     Sefc9
00EFB6  1               
00EFB6  1               ; token $26 - "," for string input
00EFB6  1               ; token $52 - "INPUT" statement for string
00EFB6  1  20 71 E1     string_input:   JSR     input_str
00EFB9  1  4C BF EF             JMP     Lefbf
00EFBC  1               
00EFBC  1               ; token $53 - "INPUT" with literal string prompt
00EFBC  1  20 03 EE     input_prompt:   JSR     print_str
00EFBF  1  A9 FF        Lefbf:  LDA     #$FF
00EFC1  1  85 C8                STA     text_index
00EFC3  1  A9 74                LDA     #$74
00EFC5  1  8D 00 02             STA     buffer
00EFC8  1  60                   RTS
00EFC9  1               
00EFC9  1  20 36 E7     Sefc9:  JSR     not_op
00EFCC  1  E8                   INX
00EFCD  1               
00EFCD  1  20 36 E7     Sefcd:  JSR     not_op
00EFD0  1  B5 50                LDA     noun_stk_l,X
00EFD2  1  60                   RTS
00EFD3  1               
00EFD3  1               ; memory initialization for 4K RAM
00EFD3  1  A9 00        mem_init_4k:    LDA     #$00
00EFD5  1  85 4A                STA     lomem
00EFD7  1  85 4C                STA     himem
00EFD9  1  A9 08                LDA     #$08
00EFDB  1  85 4B                STA     lomem+1         ; LOMEM defaults to $0800
00EFDD  1  A9 10                LDA     #$10
00EFDF  1  85 4D                STA     himem+1         ; HIMEM defaults to $1000
00EFE1  1  4C AD E5             JMP     new_cmd
00EFE4  1               
00EFE4  1  D5 78        Sefe4:  CMP     noun_stk_h_str,X
00EFE6  1  D0 01                BNE     Lefe9
00EFE8  1  18                   CLC
00EFE9  1  4C 02 E1     Lefe9:  JMP     Le102
00EFEC  1               
00EFEC  1  20 B7 E5     Tefec:  JSR     clr
00EFEF  1  4C 36 E8             JMP     run_warm
00EFF2  1               
00EFF2  1  20 B7 E5     Teff2:  JSR     clr
00EFF5  1  4C 5B E8             JMP     goto_stmt
00EFF8  1               
00EFF8  1  E0 80        Seff8:  CPX     #$80
00EFFA  1  D0 01                BNE     Leffd
00EFFC  1  88                   DEY
00EFFD  1  4C 0C E0     Leffd:  JMP     Se00c
00EFFD  1               
